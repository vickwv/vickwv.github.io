<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>InfinitasReset</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.infinitasreset.top/"/>
  <updated>2024-03-18T02:08:10.119Z</updated>
  <id>https://www.infinitasreset.top/</id>
  
  <author>
    <name>Vick</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>笔记-分布式系统关键技术-服务调度</title>
    <link href="https://www.infinitasreset.top/2023/08/06/%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF-%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    <id>https://www.infinitasreset.top/2023/08/06/%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF-%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6/</id>
    <published>2023-08-06T03:35:40.000Z</published>
    <updated>2024-03-18T02:08:10.119Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为左耳朵耗子《左耳听风》专栏中，关于分布式架构的学习笔记。</p></blockquote><p>咱们听说过的服务治理是混合了流量调度等内容，这里只讨论服务治理。服务治理关键技术如下：</p><ul><li>服务关键程度</li><li>服务依赖关系</li><li>服务发现</li><li>整个架构的版本管理</li><li>服务应用生命周期全管理</li></ul><h2 id="服务关键程度和服务的依赖关系"><a href="#服务关键程度和服务的依赖关系" class="headerlink" title="服务关键程度和服务的依赖关系"></a>服务关键程度和服务的依赖关系</h2><p><strong>服务关键程度</strong>：要梳理和定义出服务的重要程度。需要细致地管理对业务的理解，才能定义出架构中各个服务的重要程度。</p><p><strong>服务依赖关系</strong>：要梳理出服务间的依赖关系。服务依赖越多，依赖越复杂，系统就越易碎。要尽可能减少服务依赖的深度和广度，从而让服务管理更加简洁。</p><h3 id="如何减少服务依赖"><a href="#如何减少服务依赖" class="headerlink" title="如何减少服务依赖"></a>如何减少服务依赖</h3><p><strong>服务的依赖关系是可以通过技术的手段来发现的</strong>，其中，Zipkin 是一个很不错的服务调用跟踪系统。这个工具可以帮你梳理服务的依赖关系，以及了解各个服务的性能。</p><p><strong>微服务是服务依赖最优解的上限，而服务依赖的下限是千万不要有依赖环</strong>。<u>如果系统架构中有服务依赖环，那么表明架构设计是错误的。</u>循环依赖有很多的副作用，最大的问题是这是一种极强的耦合，会导致服务部署相当复杂和难解，而且会导致无穷尽的递归故障和一些你意想不到的问题。</p><p><strong>解决服务依赖环的方案一般是，依赖倒置的设计模式</strong>。在分布式架构上，可使用第三方的服务来解决这个事。比如，通过订阅或发布消息到一个消息中间件，或是把其中的依赖关系抽到一个第三方的服务中，然后由这个第三方的服务来调用这些原本循环依赖的服务。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>梳理完服务的重要程度和依赖关系后，就相当于知道了整个架构的全局。好比获取到了城市地图，可以看到城市的关键设施及主干道。再加上监控，我们就可以看到整个城市的情况。这对分布式系统非常非常关键。</p><h2 id="服务状态和生命周期管理"><a href="#服务状态和生命周期管理" class="headerlink" title="服务状态和生命周期管理"></a>服务状态和生命周期管理</h2><p>有了上面的地图，<strong>就需要一个服务发现的中间件(非常关键)</strong>，帮助我们动态管理服务。有的服务会新增，有的会离开，有的会维护，所以需要一个<strong>服务注册中心</strong>，来知道这么几个事。</p><ul><li>有多少中服务</li><li>服务的版本是什么样的？</li><li>每个服务的实例数有多少，实例状态是什么样的？</li><li>每个服务的状态是什么样的？是在部署中、运行中，故障中，升级中，还是再回滚中、伸缩中，或是再下线中……</li></ul><p>知晓服务的状态和运行情况之后，就需要对这些服务的生命周期进行管理了。服务的生命周期通常会有以下几个状态：</p><ul><li>Provision，代表在供应一个新的服务；</li><li>Ready，表示启动成功了；</li><li>Run，表示通过了服务健康检查；</li><li>Update，表示在升级中；</li><li>Rollback，表示在回滚中；</li><li>Scale，表示正在伸缩中（可以有 Scale-in 和 Scale-out 两种）；</li><li>Destroy，表示在销毁中；</li><li>Failed，表示失败状态。</li></ul><p>这几个状态需要管理好，不然的话，无法知道这些服务在什么样的状态下。不知道在什么样的状态下，就对整个分布式架构也就无法控制了。</p><p>有了这些服务的状态和生命周期的管理，以及服务的重要程度和服务的依赖关系，再加上一个服务运行状态的拟合控制（后面会提到），你一下子就有了管理整个分布式服务的手段了。</p><h2 id="整个架构的版本管理"><a href="#整个架构的版本管理" class="headerlink" title="整个架构的版本管理"></a>整个架构的版本管理</h2><p>由于每个服务都有版本依赖及版本兼容性，比如 A 服务的 1.2 版本只能和 B 服务的 2.2 版本工作。<strong>所以在分布式架构中，也需要一个架构的版本，用来控制其中各个服务的版本兼容。</strong></p><p>如果架构中有这样的问题，那么我们就需要一个上层架构的版本管理。这样，如果我们要回滚一个服务的版本，就可以把与之有版本依赖的服务也一起回滚掉。</p><p>要做到版本管理，需要一个架构的 mainfest，一个服务清单，这个服务清单定义了所有服务的版本运行环境，其中包括但不限于：</p><ul><li>服务的软件版本；</li><li>服务的运行环境 （环境变量、CPU、内存、可运行的节点、文件系统等）；</li><li>服务运行的最大最小实例数。</li></ul><p>每一次变更都要被记录下来，算是架构的版本管理（亚马逊做这个事，叫 VersionSet）。</p><h2 id="资源-服务调度"><a href="#资源-服务调度" class="headerlink" title="资源/服务调度"></a>资源/服务调度</h2><p>服务和资源的调度有点像操作系统。操作系统一方面把用户进程在硬件资源上进行调度，另一方面提供进程间的通信方式，可以让不同的进程在一起协同工作。服务和资源调度的过程，与操作系统调度进程的方式很相似，主要有以下一些关键技术。</p><ul><li>服务状态的维持和拟合。</li><li>服务的弹性伸缩和故障迁移。</li><li>作业和应用调度。</li><li>作业工作流编排。</li><li>服务编排。</li></ul><h3 id="服务状态的维持和拟合"><a href="#服务状态的维持和拟合" class="headerlink" title="服务状态的维持和拟合"></a>服务状态的维持和拟合</h3><p>服务状态指的是服务的运行状态（Status，上面的生命周期中的状态）。</p><p>服务运行过程中，状态也是会有变化的，服务状态会有两种变化：</p><ul><li>没有预期的变化。比如，服务因为故障导致一些服务挂了。好的集群管理控制器应能强行维护状态，在健康实例变少的时候，控制器会把不健康的摘除，又启动几个新的，强行维护健康的实例数。</li><li>预期的变化。比如，发布新版本，需要伸缩，需要回滚。集群管理控制器就应该把集群从现有状态迁移到另一个新的状态。<u>这个过程并不是一蹴而就的，集群控制器需要一步一步地向集群发送若干控制命令。这个过程叫“拟合”——从一个状态拟合到另一个状态，而且要穷尽所有的可能，玩命地不断地拟合，直到达到目的。</u></li></ul><p>详细说明一下，对于分布式系统的服务管理来说，当需要把一个状态变成另一个状态时，我们需要对集群进行一系列的操作。比如，当需要对集群进行 Scale 的时候，我们需要：</p><ul><li>先扩展出几个结点；</li><li>再往上部署服务；</li><li>然后启动服务；</li><li>再检查服务的健康情况；</li><li>最后把新扩展出来的服务实例加入服务发现中提供服务。</li></ul><p>可以看到，这是一个比较稳健和严谨的 Scale 过程，这需要集群控制器往生产集群中进行若干次操作。</p><h3 id="服务的弹性伸缩和故障迁移"><a href="#服务的弹性伸缩和故障迁移" class="headerlink" title="服务的弹性伸缩和故障迁移"></a>服务的弹性伸缩和故障迁移</h3><p>有了服务的状态拟合的基础工作后，就可以很容易管理服务的生命周期了，甚至可以通过底层的支持进行便利的服务弹性伸缩和故障管理。</p><p>弹性伸缩，涉及到以下几点：</p><ul><li>底层资源的伸缩；</li><li>服务的自动化部署；</li><li>服务的健康检查；</li><li>服务发现的注册；</li><li>服务流量的调度。</li></ul><p>故障迁移，也就是服务的某个实例出现问题时，需要自动地恢复它。对于服务来说，有两种模式，一种是宠物模式，一种是奶牛模式。</p><ul><li>所谓宠物模式，就是一定要救活，主要是对于 stateful 的服务。</li><li>而奶牛模式，就是不用救活了，重新生成一个实例。</li></ul><p>对于这两种模式，在运行中也是比较复杂的，其中涉及到了：</p><ul><li>服务的健康监控（这可能需要一个 APM 的监控）。</li><li>如果是宠物模式，需要：服务的重新启动和服务的监控报警（如果重试恢复不成功，需要人工介入）。</li><li>如果是奶牛模式，需要：服务的资源申请，服务的自动化部署，服务发现的注册，以及服务的流量调度。</li></ul><p>弹性伸缩和故障恢复需要很相似的技术步骤，要完成这些事情并不容易，不过好在现在有 Docker 和 Kubernetes 这样的技术，就可以比较容易做这个工作。</p><p>但是，需要把传统的服务迁移到 Docker 和 Kubernetes 上来，再加上更上层的对服务生命周期的控制系统的调度，我们就可以做到一个完全自动化的运维架构。</p><h3 id="服务工作流和编排"><a href="#服务工作流和编排" class="headerlink" title="服务工作流和编排"></a>服务工作流和编排</h3><p>一个好的操作系统能够通过一定机制把一堆独立的工作进程给协同起来。在分布式的服务调度中，这个工作叫作编排（Orchestration）。</p><p>传统的 SOA 是通过 ESB（Enterprise Service Bus）——企业服务总线来完成的。ESB 的主要功能是服务通信路由、协议转换、服务编制和业务规则应用等。<br>注意，ESB 的服务编制叫 Choreography，与我们说的 Orchestration 是不一样的。</p><ul><li>Orchestration 的意思是，一个服务像大脑一样来告诉大家应该怎么交互，就跟乐队的指挥一样。（查看Service-oriented Design：A Multi-viewpoint Approach，了解更多信息）。</li><li>Choreography 的意思是，在各自完成专属自己的工作的基础上，怎样互相协作，就跟芭蕾舞团的舞者一样。</li></ul><p>在微服务中，使用更为轻量的中间件来取代 ESB 的服务编排功能。<br>简单来说，<u>这需要一个 API Gateway 或一个简单的消息队列来做相应的编排工作</u>。在 Spring Cloud 中，所有的请求都统一通过 API Gateway（Zuul）来访问内部的服务。这个和 Kubernetes 中的 Ingress 相似。</p><p>关于服务的编排会直接导致一个服务编排的工作流引擎中间件的产生。通过工作流引擎，可以非常快速地将若干个服务编排起来形成一个业务流程。（ AWS 上的 Simple Workflow 服务）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为左耳朵耗子《左耳听风》专栏中，关于分布式架构的学习笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;咱们听说过的服务治理是混合了流量调度等内容，这里只讨论服务治理。服务治理关键技术如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务关键程度&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
    
      <category term="分布式系统学习笔记" scheme="https://www.infinitasreset.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记-分布式系统关键技术-全栈监控</title>
    <link href="https://www.infinitasreset.top/2023/08/05/%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF-%E5%85%A8%E6%A0%88%E7%9B%91%E6%8E%A7/"/>
    <id>https://www.infinitasreset.top/2023/08/05/%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF-%E5%85%A8%E6%A0%88%E7%9B%91%E6%8E%A7/</id>
    <published>2023-08-05T05:55:31.000Z</published>
    <updated>2024-03-18T02:08:10.112Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为左耳朵耗子《左耳听风》专栏中，关于分布式架构的学习笔记。 </p></blockquote><p>全栈监控，其实是三层监控。在分布式系统中，监控是我们的眼睛，没有监控，我们就不知道系统到底发生了什么，继而无法管理系统。</p><ul><li><strong>基础层</strong>：监控主机和底层资源。比如： CPU、内存、网络吞吐、磁盘IO等。</li><li><strong>中间层</strong>：中间件层监控。比如：Nginx、Redis、MySQL、Kafka 等。</li><li><strong>应用层</strong>：监控应用层的使用。比如：HTTP 访问的吞吐量、响应实践、响应时间、调用链路、性能瓶颈，还包括用户端的监控。<img src="/2023/08/05/笔记-分布式系统关键技术-全栈监控/全栈监控.png" title="全栈监控"></li></ul><p>再加上监控的标准化。</p><ul><li>日志数据结构化；</li><li>监控数据格式标准化；</li><li>统一的监控平台；</li><li>统一的日志分析。</li></ul><h2 id="好的监控系统特征"><a href="#好的监控系统特征" class="headerlink" title="好的监控系统特征"></a>好的监控系统特征</h2><p>不好的监控系统存在的问题</p><ul><li><strong>监控数据是隔离开的</strong>。因为公司分工问题，存在各管各的，监控系统之间无法串起来。</li><li><strong>监控的数据项太多</strong>。信息太多等于没有信息，要抓重点。</li></ul><p>好的监控系统应有以下特征：</p><ul><li><strong>关注于整体应用的 SLA</strong>。要从为用户服务的 API 来监控整个系统。</li><li><strong>关联指标聚合</strong>。关联的系统及其指标聚合展示。要展示三层系统数据：基础层、平台中间件层和应用层。<u>最重要的是无论服务运行到哪里，需要把服务的实例和主机关联在一起</u>。</li><li><strong>快速故障定位</strong>。快速定位问题需要对整个分布式系统做一个用户请求跟踪的 trace 监控，我们需要监控到所有的请求在分布式系统中的调用链，这个事最好是做成<u>没有侵入</u>性的</li></ul><p>好的监控系统应有以下两个场景：</p><p><strong>体检</strong></p><ul><li>容量管理。提供一个全局的系统运行时数据的展示，可以让工程师团队知道是否需要增加机器或者其它资源。</li><li>性能管理。可以通过查看大盘，找到系统瓶颈，并有针对性地优化系统和相应代码</li></ul><p><strong>急诊</strong></p><ul><li>定位问题。可以快速地暴露并找到问题的发生点，帮助技术人员诊断问题。</li><li>性能分析。当出现非预期的流量提升时，可以快速地找到系统的瓶颈，并帮助开发人员深入代码。</li></ul><h2 id="如何做出好的监控系统"><a href="#如何做出好的监控系统" class="headerlink" title="如何做出好的监控系统"></a>如何做出好的监控系统</h2><p>一个好的监控系统应实现以下功能：</p><ul><li><p><strong>服务调用链跟踪</strong>。应从对外的 API 开始，将后台的实际服务关联起来，再进一步将这个服务的依赖服务关联起来，直到最后一个服务（如 MySQL、Redis）。最佳实践是 Google Dapper 系统，开源实现为 Zipkin。对于 Java 类的服务，可使用字节码技术进行字节码注入，做到代码无侵入式。</p><img src="/2023/08/05/笔记-分布式系统关键技术-全栈监控/服务调用链.png" title="服务调用链"></li><li><p><strong>服务调用时长分布</strong>。使用 Zipkin，可以看到一个服务调用链上的时间分布，这样有助于我们知道最耗时的服务是什么。</p><img src="/2023/08/05/笔记-分布式系统关键技术-全栈监控/服务调用时长.png" title="服务调用时长"></li><li><p><strong>服务的 TOP N 视图</strong>。系统请求的排名情况。一般来说，会有三种排名的方法：a）按调用量排名，b) 按请求最耗时排名，c）按热点排名（一个时间段内的请求次数的响应时间和）</p><img src="/2023/08/05/笔记-分布式系统关键技术-全栈监控/服务TOPN视图.png" title="服务TOPN视图"></li><li><p><strong>数据库操作关联</strong>。对于 Java 应用，我们可以很方便地通过 JavaAgent 字节码注入技术拿到 JDBC 执行数据库操作的执行时间。对此，我们可以和相关的请求对应起来。</p><img src="/2023/08/05/笔记-分布式系统关键技术-全栈监控/服务字节码.png" title="服务字节码"></li><li><p><strong>服务资源跟踪</strong>。服务可能运行在物理机或虚拟机或容器中，需要把服务运行的机器节点上的数据（CPU、MEM、IO、DISK、NETWORK）关联起来。</p></li></ul><p>有了以上数据，我们可以快速定位问题。</p><ol><li>当 SQL过慢，能马上知道会影响哪个 API</li><li>当消息队列阻塞，能马上知道会影响到哪个 API</li><li>当服务响应过慢，能马上关联出来是否在做 Java GC，或是所在计算结点存在资源不足的情况，又或是依赖的服务出现问题。</li></ol><p>一旦发现问题，就方便做系统调度。比如：</p><ul><li>一旦发现某个服务过慢是因为 CPU 使用过多，我们就可以做弹性伸缩。</li><li>一旦发现某个服务过慢是因为 MySQL 出现了一个慢查询，我们就无法在应用层上做弹性伸缩，只能做流量限制，或是降级操作了</li></ul><img src="/2023/08/05/笔记-分布式系统关键技术-全栈监控/服务调用链异常.png" title="服务调用链异常"><p>所以，一个分布式系统，或是一个自动化运维系统，或是一个 Cloud Native 的云化系统，<u>最重要的事就是把监控系统做好。在把数据收集好的同时，更重要的是把数据关联好</u>。这样，我们才可能很快地定位故障，进而才能进行自动化调度</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为左耳朵耗子《左耳听风》专栏中，关于分布式架构的学习笔记。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;全栈监控，其实是三层监控。在分布式系统中，监控是我们的眼睛，没有监控，我们就不知道系统到底发生了什么，继而无法管理系统。&lt;/p&gt;
&lt;ul&gt;

      
    
    </summary>
    
    
    
      <category term="分布式系统学习笔记" scheme="https://www.infinitasreset.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记-分布式系统技术栈</title>
    <link href="https://www.infinitasreset.top/2023/08/05/%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <id>https://www.infinitasreset.top/2023/08/05/%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A0%88/</id>
    <published>2023-08-05T02:16:04.000Z</published>
    <updated>2024-03-18T02:08:10.119Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为左耳朵耗子《左耳听风》专栏中，关于分布式架构的学习笔记。 </p></blockquote><p>构建分布式系统目的是增加系统容量，提高系统的可用性，转换成技术方面，完成以下两件事。</p><ul><li>大流量处理。通过集群技术把并发分摊到不同的机器上。<ul><li>实际就是<strong>提高架构性能</strong>，提高整体架构吞吐量，服务更多的并发和流量</li></ul></li><li>关键业务保护。提高服务的可用性，故障隔离阻止多米诺骨牌效应。如果流量过大，需要对业务降级，保护关键业务流转。<ul><li>实际就是<strong>提高架构稳定性</strong>，让系统的可用性更高。</li></ul></li></ul><p>对于一般公司来说，在初期，会使用读写分离的数据镜像方式，而后期会采用分库分表的方式。</p><h2 id="提高架构性能的技术"><a href="#提高架构性能的技术" class="headerlink" title="提高架构性能的技术"></a>提高架构性能的技术</h2><img src="/2023/08/05/笔记-分布式系统技术栈/提高架构性能.png" title="提高架构性能"><ul><li>缓存技术。可有效提高系统的访问能力，提高访问能力最有效手机。从前端的浏览器，到网络，再到后端服务，底层的数据库、文件系统、硬盘和 CPU，全都有缓存。分布式系统下，需要缓存集群，这也需要 Proxy 来做缓存的分片和路由。</li><li>负载均衡系统。水平拓展的关键技术，使用多台机器来分担流量。</li><li>异步调用。利用消息队列对请求做排队处理。可增加系统的吞吐量，但实用性就差了，同时会引入消息丢失的问题，所以要对消息做持久化。</li><li>数据分区和数据镜像。<strong>数据分区</strong>是把数据按一定的方式分成多个区（比如通过地理位置），不同的数据区来分担不同区的流量。这需要一个数据路由的中间件，会导致跨库的 Join 和跨库的事务非常复杂。而<strong>数据镜像</strong>是把一个数据库镜像成多份一样的数据，这样就不需要数据路由的中间件了。你可以在任意结点上进行读写，内部会自行同步数据。然而，数据镜像中最大的问题就是数据的一致性问题。</li></ul><h2 id="提高架构稳定性技术"><a href="#提高架构稳定性技术" class="headerlink" title="提高架构稳定性技术"></a>提高架构稳定性技术</h2><img src="/2023/08/05/笔记-分布式系统技术栈/提高架构的稳定性.png" title="提高架构的稳定性"><ul><li>服务拆分。主要两个目的：一是为了故障隔离，二是为了重用服务模块。拆分后会引入服务间依赖问题。</li><li>服务冗余。解决单点故障，并支持弹性伸缩，故障迁移。对于有状态的服务，冗余带来了更高的复杂性；还有弹性伸缩要考虑数据的复制或重新分片，迁移的时候还要迁移数据到其它机器。</li><li>限流降级。系统实在扛不住压力时，只能通过限流拒绝一部分业务或功能降级的方式停掉一部分服务，以确保整个架构不会挂掉。</li><li>高可用架构。通常从冗余架构的角度来保障可用性。比如，多租户隔离，灾备多活，或是数据可以在其中复制保持一致性的集群。总之，就是为了不出单点故障。</li><li>高可用运维。指的是 DevOps 中的 CI/CD（持续集成 / 持续部署）。一个良好的运维应该是一条很流畅的软件发布管线，其中做了足够的自动化测试，还可以做相应的灰度发布，以及对线上系统的自动化控制。这样，可以做到“计划内”或是“非计划内”的宕机事件的时长最短。</li></ul><p>这些技术非常有技术含量，而且需要投入大量的时间和精力。</p><h2 id="解决分布式带来的技术问题"><a href="#解决分布式带来的技术问题" class="headerlink" title="解决分布式带来的技术问题"></a>解决分布式带来的技术问题</h2><p>引入分布式系统，会引入一堆技术问题，需要从以下几个方面来解决。</p><ul><li><p>服务治理。意义在于需要把服务间的依赖关系，调用链，及关键服务梳理出来，并进行性能和可用性方面的管理。</p></li><li><p>架构软件管理。服务之间有依赖，而且有兼容性问题，所以，<u>整体服务所形成的架构需要有架构版本管理、整体架构的生命周期管理，以及对服务的编排、聚合、事务处理等服务调度功能</u>。</p></li><li><p>DevOps。分布式系统可以更为快速地更新服务，但是对于服务的测试和部署都会是挑战。所以，还需要 DevOps 的全流程，其中包括环境构建、持续集成、持续部署等。</p></li><li><p>自动化运维。有了 DevOps 后，就可以对服务进行自动伸缩、故障迁移、配置管理、状态管理等一系列的自动化运维技术了。</p></li><li><p>资源调度管理。应用层的自动化运维需要基础层的调度支持，也就是云计算 IaaS 层的计算、存储、网络等资源调度、隔离和管理。</p></li><li><p>整体架构监控。<u>如果没有一个好的监控系统，那么自动化运维和资源调度管理只可能成为一个泡影，因为监控系统是你的眼睛</u>。没有眼睛，没有数据，就无法进行高效运维。所以说，监控是非常重要的部分。这里的监控需要对三层系统（应用层、中间件层、基础层）进行监控。</p></li><li><p>流量控制。最后是我们的流量控制，负载均衡、服务路由、熔断、降级、限流等和流量相关的调度都会在这里，包括灰度发布之类的功能也在这里。</p></li></ul><p>分布式中最大的坑，要做好以上这么多技术或具备这么多的能力。不过可通过 Docker 以及其衍生出来的 Kubernetes 之类的软件或解决方案，大大地降低了做上面很多事情的门槛。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分布式系统五个关键技术：</p><img src="/2023/08/05/笔记-分布式系统技术栈/分布式系统关键技术总结.png" title="分布式系统关键技术总结"><ul><li>全栈系统监控</li><li>服务 / 资源调度</li><li>流量调度</li><li>状态 / 数据调度（数据方面分布式处理）</li><li>开发和运维的自动化</li></ul><p>最后一项——开发和运维的自动化，是需要把前四项都做到了，才有可能实现的。所以，最为关键是下面这四项技术，即应用整体监控、资源和服务调度、状态和数据调度及流量调度，它们是构建分布式系统最最核心的东西。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为左耳朵耗子《左耳听风》专栏中，关于分布式架构的学习笔记。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;构建分布式系统目的是增加系统容量，提高系统的可用性，转换成技术方面，完成以下两件事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大流量处理。通过集群技术把并
      
    
    </summary>
    
    
    
      <category term="分布式系统学习笔记" scheme="https://www.infinitasreset.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记-分布式系统初识</title>
    <link href="https://www.infinitasreset.top/2023/08/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%88%9D%E8%AF%86/"/>
    <id>https://www.infinitasreset.top/2023/08/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%88%9D%E8%AF%86/</id>
    <published>2023-08-03T15:07:11.000Z</published>
    <updated>2024-03-18T02:08:10.106Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为左耳朵耗子《左耳听风》专栏中，关于分布式架构的学习笔记。 </p></blockquote><h2 id="为什么需要分布式架构"><a href="#为什么需要分布式架构" class="headerlink" title="为什么需要分布式架构"></a>为什么需要分布式架构</h2><ul><li><strong>增大系统容量</strong>。随着业务量增大，单机无法满足需求，需要多台机器才能应对，所以需要垂直或水平拆分系统，变成一个分布式架构</li><li><strong>加强系统可用</strong>。单体架构存在单点故障，为了提高系统的可用性，可以通过分布式系统来冗余系统，消除单点故障。</li></ul><h2 id="单体架构对比分布式架构"><a href="#单体架构对比分布式架构" class="headerlink" title="单体架构对比分布式架构"></a>单体架构对比分布式架构</h2><img src="/2023/08/03/分布式系统初识/单体与分布式对比图.png" title="单体与分布式对比图"><p>所以采用分布式系统架构后会出现很多的问题。比如：</p><ul><li>一个线上故障的工单会在不同的服务和不同的团队中转过来转过去。</li><li>每个团队都可能成为一个潜在的 DDoS 攻击者，除非每个服务都要做好配额和限流。</li><li>监控和查错变得更为复杂。除非有非常强大的监控手段。</li><li>服务发现和服务治理也变得非常复杂。</li></ul><h3 id="如何克服分布式架构问题"><a href="#如何克服分布式架构问题" class="headerlink" title="如何克服分布式架构问题"></a>如何克服分布式架构问题</h3><ul><li><strong>分布式服务的架构需要分布式的团队架构</strong>。每个服务按小团队负责，按职责分工。</li><li><strong>分布式服务查错不容易。一旦出现比较严重的故障，需要整体查错</strong>。出现一个 S2 的故障，就可以看到每个团队的人都会上线。在工单系统里能看到，在故障发生的一开始，大家都在签到并自查自己的系统。如果没问题，也要在线待命（standby），等问题解决。</li><li><strong>没有专职的测试人员，也没有专职的运维人员，开发人员做所有的事情</strong>。开发人员做所有事情的好处是——吃自己的狗粮（Eat Your Own Dog Food）。自己写的代码自己维护自己养，会让开发人员明白，写代码容易维护代码复杂。这样，开发人员在接需求、做设计、写代码、做工具时都会考虑到软件的长期维护性。</li><li><strong>运维优先，崇尚简化和自动化。</strong> 简单说要做好 DveOps。</li><li><strong>内部服务和外部服务一致。</strong> 无论是从安全方面，还是接口设计方面，无论是从运维方面，还是故障处理的流程方面，亚马逊的内部系统都和外部系统一样对待。这样做的好处是，内部系统的服务随时都可以开放出来。而且，从第一天开始，服务提供方就有对外服务的能力。</li></ul><h2 id="分布式系统中需要注意的技术问题"><a href="#分布式系统中需要注意的技术问题" class="headerlink" title="分布式系统中需要注意的技术问题"></a>分布式系统中需要注意的技术问题</h2><ol><li><p>异构系统的不标准问题</p><ul><li>软件和应用不标准。不同软件、不同语言会出现不同的兼容性和不同的开发、运维、测试标准。<ul><li>比如有的软件修改配置要改 conf 文件，有的是调用 API 接口。</li></ul></li><li>通讯协议不标准<ul><li>比如协议一定要有协议头和协议体。协议头定义基本协议数据，协议体才放业务数据。</li><li>比如软件配置管理用 key-value 容易被滥用。</li><li>好的配置分3层，底层和操作系统相关，中间层和中间件相关，最上面和业务应用相关。于是底层和中间层是不能让用户灵活修改的，而是只让用户选择。</li></ul></li><li>数据结构不标准</li><li>开发和运维的过程和方法不标准</li></ul></li><li><p>系统架构中的服务依赖性问题<br> 分布式系统，服务存在依赖，一个服务依赖链上的某个服务挂了，也有可能导致整个服务挂。</p><ul><li>如果非关键业务被关键业务所依赖，会导致非关键业务变成一个关键业务。</li><li>服务依赖链中，出现“木桶短板效应”——整个 SLA 由最差的那个服务所决定。</li><li>需要注意，分布式架构不仅业务要做隔离，数据库也需要做隔离，不然一个非关键业务把数据库拖死，也很正常。</li></ul><p>这就需要服务治理了。服务治理不但需要我们定义出服务的关键程度，还需要我们定义或是描述出关键业务或服务调用的主要路径。</p></li><li><p>故障发生概率更大<br> 分布式系统中，由于使用的机器和服务会很多，所以故障发生的频率会比传统的单体更大。当然分布式系统故障的影响面更小，虽可被隔离，但因为机器多，出故障的概率也多。另外，因为管理复杂，而且无人知道整个架构有什么，所以容易出错。</p><p> 运维团队在分布式系统下很忙，忙到每时每刻都在处理故障。很多运维团队都在监控中拼命增加指标，但监控指标应聚焦关键指标，而不是越多越好。</p><p> 所谓防火胜于救火，需要考虑如何预防故障。所以我们再设计或运维系统时需要为故障考虑，即 <strong>Design for Failure</strong>。在设计时就要考虑如何减轻故障。如果无法避免，也要使用自动化的方式恢复故障，减少故障影响面。</p></li><li><p>多层架构运维复杂度更大。<br> 系统分为四层：基础层，平台层，应用层和接入层。</p><ul><li>基础层就是我们的机器、网络和存储设备等。</li><li>平台层就是我们的中间件层，Tomcat、MySQL、Redis、Kafka 之类的软件。</li><li>应用层就是我们的业务软件，比如，各种功能的服务。</li><li>接入层就是接入用户请求的网关、负载均衡或是 CDN、DNS 这样的东西。</li></ul><p>对于这四层，我们需要知道：</p><ul><li>任何一层的问题都会导致整体的问题；</li><li>没有统一的视图和管理，导致运维被割裂开来，造成更大的复杂度。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为左耳朵耗子《左耳听风》专栏中，关于分布式架构的学习笔记。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么需要分布式架构&quot;&gt;&lt;a href=&quot;#为什么需要分布式架构&quot; class=&quot;headerlink&quot; title=&quot;为什么需要
      
    
    </summary>
    
    
    
      <category term="分布式系统学习笔记" scheme="https://www.infinitasreset.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>k50U刷国际版无法打开相机</title>
    <link href="https://www.infinitasreset.top/2023/05/09/k50u-global-camera-driver/"/>
    <id>https://www.infinitasreset.top/2023/05/09/k50u-global-camera-driver/</id>
    <published>2023-05-09T03:51:20.000Z</published>
    <updated>2024-03-18T02:08:10.106Z</updated>
    
    <content type="html"><![CDATA[<p>众所周之，买小米是为了刷类原生。但是在类原生出来之前，刷国际版ROM可以获得一个相对干净的系统。<br>K50U 国际版型号为小米12T pro, 两者有一个区别，国际版相机驱动为2亿像素，国内版为1亿像素。<br>小米在国际版ROM没有内置1亿相机驱动（可以做到，但是不做，嫌弃），所以国内版刷国际版后，后置相机无法使用。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>利用 Magisk 替换把国际版本2亿像素驱动，替换成1亿像素驱动即可。步骤如下：</p><ol><li>提取国行版本相机驱动。<br> a. /verdor/lib/camera/com.qti.sensormodule.diting_sunny_s5khm6_wide.bin<br> b. /verdor/lib64/camera/com.qti.sensormodule.diting_sunny_s5khm6_wide.bin</li><li>将上述文件重命名为 “com.qti.sensormodule.diting_semco_s5khp1_wide.bin”, 并覆盖国际版同名文件。通过重命名覆盖驱动方式，可以让国际版固件驱动1亿像素驱动。</li><li>将以上方式制作成 Magisk 包，通过 Magisk 包来刷入即可。</li></ol><p><strong>重要提示</strong>: MIUI14 和 MIUI13 驱动文件不通用，所以分别打包。</p><p>本人已经制作好 Magisk 包，大家可以自己<a href="https://1drv.ms/f/s!AvDkpg2C4ecTivhOegakRLZuJ4KVuQ" target="_blank" rel="noopener">下载</a>刷入。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;众所周之，买小米是为了刷类原生。但是在类原生出来之前，刷国际版ROM可以获得一个相对干净的系统。&lt;br&gt;K50U 国际版型号为小米12T pro, 两者有一个区别，国际版相机驱动为2亿像素，国内版为1亿像素。&lt;br&gt;小米在国际版ROM没有内置1亿相机驱动（可以做到，但是不做
      
    
    </summary>
    
    
    
      <category term="折腾手机" scheme="https://www.infinitasreset.top/tags/%E6%8A%98%E8%85%BE%E6%89%8B%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>aws memorydb for redis 对接</title>
    <link href="https://www.infinitasreset.top/2023/05/02/aws-redis-cluster-useage/"/>
    <id>https://www.infinitasreset.top/2023/05/02/aws-redis-cluster-useage/</id>
    <published>2023-05-02T13:59:01.000Z</published>
    <updated>2024-03-18T02:08:10.106Z</updated>
    
    <content type="html"><![CDATA[<p>由于业务需要向海外发展，于是在 aws 服务器重新部署了一套服务。其中有使用到 aws memorydb for redis 集群服务，记录一下对接步骤。</p><ol><li>开通 redis 后，首先要创建安全组，允许服务器访问 endpoint。不然服务器无法访问 redis。</li><li>连接 redis 需要使用 tls 协议，不然提示连接失败。默认应该连接 DB0，否则可能会提示找不到 DB。示例如下：</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## laravel database.php</span></span><br><span class="line">    <span class="string">'redis'</span> =&gt; [  </span><br><span class="line">        <span class="string">'client'</span> =&gt; env(<span class="string">'REDIS_CLIENT'</span>, <span class="string">'predis'</span>),    </span><br><span class="line">        <span class="string">'options'</span> =&gt; [</span><br><span class="line">            <span class="string">'parameters'</span> =&gt; [<span class="string">'password'</span> =&gt; env(<span class="string">'REDIS_PASSWORD'</span>, <span class="string">''</span>)],  </span><br><span class="line">        ],    </span><br><span class="line">        <span class="string">'default'</span> =&gt; [  </span><br><span class="line">            <span class="string">'host'</span> =&gt; env(<span class="string">'REDIS_HOST'</span>, <span class="string">'127.0.0.1'</span>),  </span><br><span class="line">            <span class="string">'password'</span> =&gt; env(<span class="string">'REDIS_PASSWORD'</span>, <span class="string">''</span>),  </span><br><span class="line">            <span class="string">'port'</span> =&gt; env(<span class="string">'REDIS_PORT'</span>, <span class="string">'6379'</span>),  </span><br><span class="line">            <span class="string">'database'</span> =&gt; env(<span class="string">'REDIS_DB'</span>, <span class="number">0</span>),  </span><br><span class="line">            <span class="string">'persistent'</span> =&gt; <span class="literal">true</span>,  </span><br><span class="line">            <span class="string">'scheme'</span> =&gt; env(<span class="string">'REDIS_SCHEME'</span>, <span class="string">'tls'</span>),  </span><br><span class="line">        ],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## django-redis env</span></span><br><span class="line"><span class="comment"># rediss == redis tls</span></span><br><span class="line"><span class="attr">REDIS_URL</span>=rediss://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>/<span class="number">0</span>?client_class=django_redis.client.DefaultClient&amp;ssl_cert_reqs=None&amp;ssl=<span class="literal">True</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用 queue， queue name (hash tag) 必须要用花括号包住，为了保证每次散列都在同一个 solt。<ul><li>Redis Cluster会对key使用 CRC16 算法进行hash，然后对16384取模来确定key所属的槽位（hash tag会打破这种规则）。</li><li>标签是破坏上述计算规则的实现，Hash tag是一种保证多个键被分配到同一个槽位的方法。</li><li>hash tag的计算规则是：取一对大括号{}之间的字符进行计算，如果key存在多对大括号，那么就取第一个左括号和第一个右括号之间的字符。如果大括号之前没有字符，则会对整个字符串进行计算。<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>:&#123;user&#125;:<span class="number">1</span>, <span class="keyword">project</span>:&#123;user&#125;:<span class="number">2</span> = 计算 <span class="keyword">project</span> user的 hash值</span><br><span class="line"><span class="keyword">project</span>&#123;&#123;bar&#125;&#125;这个key就会对&#123;bar进行hash计算</span><br><span class="line"><span class="keyword">project</span>&#123;&#125;&#123;bar&#125;会对整个字符串进行计算</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于业务需要向海外发展，于是在 aws 服务器重新部署了一套服务。其中有使用到 aws memorydb for redis 集群服务，记录一下对接步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开通 redis 后，首先要创建安全组，允许服务器访问 endpoint。不然服务器无法访问
      
    
    </summary>
    
    
    
      <category term="技术踩坑" scheme="https://www.infinitasreset.top/tags/%E6%8A%80%E6%9C%AF%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>对象占用多少字节</title>
    <link href="https://www.infinitasreset.top/2022/01/04/%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82/"/>
    <id>https://www.infinitasreset.top/2022/01/04/%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82/</id>
    <published>2022-01-04T05:54:26.000Z</published>
    <updated>2024-03-18T02:08:10.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-预备知识："><a href="#1-预备知识：" class="headerlink" title="1. 预备知识："></a>1. 预备知识：</h2><h3 id="1-1-Java-对象模型"><a href="#1-1-Java-对象模型" class="headerlink" title="1.1 Java 对象模型"></a>1.1 Java 对象模型</h3><p>HotSpot JVM 使用名为 oops (Ordinary Object Pointers)  的数据结构来表示对象，对象在内存中分3部分：</p><ul><li>Header: 对象头， 分3部分，mark word、元数据指针、数组长度<ul><li>mark word : 存储 hashcode, locking pattern, locking information, and GC metadata(对象的引用计数数量，便于GC回收)，<strong>这部分在 64 位操作系统下占 8 字节，32 位操作系统下占 4 字节</strong>。 详情可查看：<a href="https://www.baeldung.com/java-memory-layout" target="_blank" rel="noopener">https://www.baeldung.com/java-memory-layout</a></li><li>kclass 指针：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪一个类的实例。<br>这部分就涉及到指针压缩的概念，<strong>在开启指针压缩的状况下占 4 字节，未开启状况下占 8 kb。</strong></li><li>数组长度：这部分只有是数组对象才有，<strong>若是是非数组对象就没这部分。这部分占 4 kb。</strong></li></ul></li><li>Instance Data: 实例数据</li><li>Alignment Padding: 对象对齐填充。Java 对象的大小默认是按照 8 字节对齐，也就是说 Java 对象的大小必须是 8 字节的倍数。若是算到最后不够 8 字节的话，那么就会进行对齐填充。</li></ul><h3 id="1-2-指针压缩"><a href="#1-2-指针压缩" class="headerlink" title="1.2 指针压缩"></a>1.2 指针压缩</h3><p>JVM 为了节省内存，如果 heap size 小于 32GB，JVM会自动开启指针压缩。大于32GB会关闭指针压缩。可以用 <em>-XX:-UseCompressedOops</em> tuning flag 强行开启指针压缩。</p><h3 id="1-3-基本类型占用空间"><a href="#1-3-基本类型占用空间" class="headerlink" title="1.3 基本类型占用空间"></a>1.3 基本类型占用空间</h3><table><thead><tr><th>类型</th><th>占用空间(byte)</th></tr></thead><tbody><tr><td>boolean</td><td>1</td></tr><tr><td>byte</td><td>1</td></tr><tr><td>short</td><td>2</td></tr><tr><td>char</td><td>2</td></tr><tr><td>int</td><td>4</td></tr><tr><td>float</td><td>4</td></tr><tr><td>long</td><td>8</td></tr><tr><td>double</td><td>8</td></tr><tr><td>object references</td><td>4，如果未开启指针压缩则为 8</td></tr></tbody></table><h3 id="1-4-GC-的基本知识"><a href="#1-4-GC-的基本知识" class="headerlink" title="1.4 GC 的基本知识"></a>1.4 GC 的基本知识</h3><ul><li>程序中存在一些实例, 称作GC root, 它们不会被GC回收, 常见的例如静态变量, 线程等</li><li>被GC root直接或间接引用的实例会被标记为in use, 它们也不会被GC回收</li></ul><h2 id="2-分析对象大小"><a href="#2-分析对象大小" class="headerlink" title="2. 分析对象大小"></a>2. 分析对象大小</h2><p><strong>以下分析基于 jdk11，64位操作系统处理。</strong></p><p>其实有3个不同的指标来分析对象大小。</p><ul><li>shallow size: 指对象自身占用的内存, 不包括引用对象的实际大小，引用对象只计算引用对象指针大小。</li><li>ratained size: 当对象自身被 GC 回收时, 对象自身 shallow size 加上其引用对象的 shallow size。<ul><li>只有加上能同时被 GC 回收的引用对象。</li><li>怎么判断引用对象能否被回收？</li><li><img src="https://www.yourkit.com/docs/java/help/retained_objects.gif" alt="引用对象图"></li><li>如上图，假设所有对象的 Shallow size 为 1 字节,<ul><li>如果要回收 obj1，obj1 引用了 obj2，obj2 又同时引用了 obj4 和 obj3</li><li>由于 obj3 同时被Gc Roots 引用，所以不能加上 obj3 的 Shallow size</li><li>所以 obj1 的 ratained size:  obj1 + obj2 + obj4 ，3个类的 Shallow size 总和为 3 字节。</li></ul></li></ul></li><li>deep size: 与 shallow size 相反，不但要计算实例自身占用的空间，还要计算引用对象的大小，需要递归计算。</li></ul><p>接下来会用代码实际分析对象大小</p><p>代码依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基础代码类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Course</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-Shallow-Size"><a href="#2-1-Shallow-Size" class="headerlink" title="2.1 Shallow Size"></a>2.1 Shallow Size</h3><p>计算公式：<strong>对象头 + 实例数据 + 对齐填充字节</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectsSizeMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String ds = <span class="string">"Data Structures"</span>;</span><br><span class="line">        Course course = <span class="keyword">new</span> Course(ds);</span><br><span class="line">        System.out.println(<span class="string">"The shallow size is: "</span> + VM.current().sizeOf(course));</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(course).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">The shallow size is: <span class="number">16</span></span><br><span class="line">org.example.objects_size.Course object internals:</span><br><span class="line"> OFFSET  SIZE               TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>                    (object header)                           <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>                    (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>                    (object header)                           <span class="number">48</span> <span class="number">72</span> <span class="number">06</span> <span class="number">00</span> (<span class="number">01001000</span> <span class="number">01110010</span> <span class="number">00000110</span> <span class="number">00000000</span>) (<span class="number">422472</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>   java.lang.String Course.name                               (object)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">0</span> bytes external = <span class="number">0</span> bytes total</span><br></pre></td></tr></table></figure><p>实例数据：Course 类只有一个 String 类的类属性 name ，所以占用 4 字节。</p><p>对象头：Couse 类非数组对象，所以占用 12 字节</p><p>对齐填充字节： 由于对象头+实例数据=16字节，所以不需要填充，填充字节为 0。</p><p><strong>所以 Course 类实例 shallow size 是16字节。</strong></p><h3 id="2-2-Ratained-Size"><a href="#2-2-Ratained-Size" class="headerlink" title="2.2 Ratained Size"></a>2.2 Ratained Size</h3><p>计算公式：<strong>对象自身的 Shallow Size + 引用对象的 Shallow Size</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectsSizeMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String ds = <span class="string">"Data Structures"</span>;</span><br><span class="line">        Course course = <span class="keyword">new</span> Course(ds);</span><br><span class="line">        System.out.println(<span class="string">"course size is: "</span> + VM.current().sizeOf(course));</span><br><span class="line">        System.out.println(<span class="string">"name size is: "</span> + VM.current().sizeOf(ds));</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(ds).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Course 自身的 shallow size: 16 字节</p><p>引用对象的 shallow size：Course 的引用对象为 name， 是个 String 类，可以用<code>ClassLayout.parseInstance(course.getName()).toPrintable()</code>分析大小。</p><p>Course.name 的对象大小：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.String object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET  SIZE     TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>          (object header)                           <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>          (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>          (object header)                           <span class="number">08</span> <span class="number">18</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00001000</span> <span class="number">00011000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">6152</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>   byte[] String.value                              [<span class="number">68</span>, <span class="number">97</span>, <span class="number">116</span>, <span class="number">97</span>, <span class="number">32</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">117</span>, <span class="number">99</span>, <span class="number">116</span>, <span class="number">117</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">115</span>]</span><br><span class="line">     <span class="number">16</span>     <span class="number">4</span>      <span class="built_in">int</span> String.hash                               <span class="number">0</span></span><br><span class="line">     <span class="number">20</span>     <span class="number">1</span>     byte String.coder                              <span class="number">0</span></span><br><span class="line">     <span class="number">21</span>     <span class="number">3</span>          (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes <span class="built_in">int</span>ernal + <span class="number">3</span> bytes <span class="keyword">external</span> = <span class="number">3</span> bytes total</span><br></pre></td></tr></table></figure><p>可以看到 String 对象大小为 24 字节。其中请求头 12 字节 ，byte[] 数据 4 字节，hash code 4 字节，byte coder 1 字节，对齐填充 3 字节。</p><p><strong>所以 Course 类的 ratained size = 16+24=40 字节。</strong></p><h3 id="2-3-Deep-Size"><a href="#2-3-Deep-Size" class="headerlink" title="2.3 Deep Size"></a>2.3 Deep Size</h3><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectsSizeMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String ds = <span class="string">"Data Structures"</span>;</span><br><span class="line">        Course course = <span class="keyword">new</span> Course(ds);</span><br><span class="line">        System.out.println(<span class="string">"course size is: "</span> + VM.current().sizeOf(course));</span><br><span class="line">        System.out.println(<span class="string">"name size is: "</span> + VM.current().sizeOf(ds));</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(ds.getBytes()).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上已知，Course 类对象大小是 16 字节，String 类对象大小是 24 字节。只要在加上 String 对象实际数据大小就是 Deep Size。</p><p>可以通过 <code>ClassLayout.parseInstance(ds.getBytes()).toPrintable()</code>获取 String 对象实际数据大小。</p><p>输出：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[B object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">20</span> <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00100000</span> <span class="number">00001000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">2080</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (object header)                           <span class="number">0f</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00001111</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">15</span>)</span><br><span class="line">     <span class="number">16</span>    <span class="number">15</span>   byte [B.&lt;elements&gt;                             N/A</span><br><span class="line">     <span class="number">31</span>     <span class="number">1</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">32</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes <span class="built_in">int</span>ernal + <span class="number">1</span> bytes <span class="keyword">external</span> = <span class="number">1</span> bytes total</span><br></pre></td></tr></table></figure><p> String 对象实际数据大小为 32 字节。其中请求头为 16 字节（mark word 8 字节+ kclass 指针 4 字节 + 数据长度 4 字节），实际数据为 15 字节，对齐填充 1 字节。</p><p><strong>所以 Course 类的 deep size 为 16+24+32=72 字节。</strong></p><blockquote><p>注:jdk8 下 String 类的 value 为 char[]，所以要计算 char[]的大小, 由于 char array 为 48 字节，所以 jdk8 下 deep size 为 16+24+48=88 字节</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-预备知识：&quot;&gt;&lt;a href=&quot;#1-预备知识：&quot; class=&quot;headerlink&quot; title=&quot;1. 预备知识：&quot;&gt;&lt;/a&gt;1. 预备知识：&lt;/h2&gt;&lt;h3 id=&quot;1-1-Java-对象模型&quot;&gt;&lt;a href=&quot;#1-1-Java-对象模型&quot; cla
      
    
    </summary>
    
    
    
      <category term="Java 学习" scheme="https://www.infinitasreset.top/tags/Java-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-Cursor</title>
    <link href="https://www.infinitasreset.top/2020/01/13/mysql-cursor/"/>
    <id>https://www.infinitasreset.top/2020/01/13/mysql-cursor/</id>
    <published>2020-01-13T09:04:18.000Z</published>
    <updated>2024-03-18T02:08:10.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-游标-Cursor"><a href="#1-游标-Cursor" class="headerlink" title="1. 游标(Cursor)"></a>1. 游标(Cursor)</h2><p>游标的作用是从一个结果集中逐条获取记录并操作它们。相比select语句，select语句是直接获取结果集(即集合取数据)，然后在应用程序里操作整个结果集。<strong>集合取数据的关注点</strong>在于想要什么数据，而不关注怎么去获取数据；<strong>游标的关注点</strong>是怎么获取数据，并将游标指针作为遍历依据，遍历到哪行返回哪行数据，然后处理数据，再继续遍历。</p><h3 id="1-1-1-游标的属性"><a href="#1-1-1-游标的属性" class="headerlink" title="1.1.1. 游标的属性"></a>1.1.1. 游标的属性</h3><ol><li>服务器层可能会也可以能不会复制结果集</li><li>不可以更新行数据</li><li>只能向前(一个方向上)遍历，不能跳过行</li></ol><h3 id="1-1-2-游标的使用"><a href="#1-1-2-游标的使用" class="headerlink" title="1.1.2. 游标的使用"></a>1.1.2. 游标的使用</h3><p>游标是一种复合语句结构(就像begin…end)，只能用于stored procedure或stored function中。游标的使用包括声明游标、打开游标、使用游标、关闭游标。</p><p>示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> curdemo()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">DECLARE</span> done <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="literal">FALSE</span>;</span><br><span class="line">  <span class="keyword">DECLARE</span> a <span class="built_in">CHAR</span>(<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">DECLARE</span> b, c <span class="built_in">INT</span>;</span><br><span class="line">  <span class="keyword">DECLARE</span> cur1 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">data</span> <span class="keyword">FROM</span> test.t1;</span><br><span class="line">  <span class="keyword">DECLARE</span> cur2 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> i <span class="keyword">FROM</span> test.t2;</span><br><span class="line">  <span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">NOT</span> <span class="keyword">FOUND</span> <span class="keyword">SET</span> done = <span class="literal">TRUE</span>;</span><br><span class="line"></span><br><span class="line">  OPEN cur1;</span><br><span class="line">  OPEN cur2;</span><br><span class="line"></span><br><span class="line">  read_loop: LOOP</span><br><span class="line">    FETCH cur1 INTO a, b;</span><br><span class="line">    FETCH cur2 INTO c;</span><br><span class="line">    IF done THEN</span><br><span class="line">      LEAVE read_loop;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    IF b &lt; c THEN</span><br><span class="line">      <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.t3 <span class="keyword">VALUES</span> (a,b);</span><br><span class="line">    ELSE</span><br><span class="line">      <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.t3 <span class="keyword">VALUES</span> (a,c);</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"></span><br><span class="line">  CLOSE cur1;</span><br><span class="line">  CLOSE cur2;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></p><h4 id="1-1-2-1-声明游标"><a href="#1-1-2-1-声明游标" class="headerlink" title="1.1.2.1. 声明游标"></a>1.1.2.1. 声明游标</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> select_statement</span><br></pre></td></tr></table></figure><p>select_statement是游标需要从中获取的结果集。游标声明必须出现在处理程序声明之前以及变量和条件声明之后。<br>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">test</span> <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> * <span class="keyword">from</span> emplyeels;</span><br></pre></td></tr></table></figure></p><h4 id="1-1-2-2-声明处理程序"><a href="#1-1-2-2-声明处理程序" class="headerlink" title="1.1.2.2. 声明处理程序"></a>1.1.2.2. 声明处理程序</h4><p>一般使用游标都会在循环结构中获取数据存储到变量中。但是取完数据后如何退出循环？</p><p>在游标无法获取到下一行数据的时候，将会返回1329错误码，这个错误码对应的SQL状态为“02000”，它们等价于NOT FOUND。这时可以在声明游标后定义一个handler，用于处理NOT FOUND。</p><p>例如下面是游标NOT FOUND时的CONTINUE处理器，表示当找不到下一行数据时继续执行后面的程序：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">NOT</span> <span class="keyword">FOUND</span> statment;</span><br></pre></td></tr></table></figure></p><p>对于处理游标的HANDLER，通常statement部分是SET语句，用于设置一些变量。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> continue <span class="keyword">handler</span> <span class="keyword">for</span> <span class="keyword">not</span> <span class="keyword">found</span> <span class="keyword">for</span> var_name=<span class="keyword">value</span>;</span><br></pre></td></tr></table></figure></p><p>这时当取不到下一条记录时就设置变量var_name=value。这样就可以通过该变量的值作为退出循环的条件。</p><h4 id="1-1-2-3-打开游标"><a href="#1-1-2-3-打开游标" class="headerlink" title="1.1.2.3. 打开游标"></a>1.1.2.3. 打开游标</h4><p>当声明一个游标后，必须要打开游标才能使用游标。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open cursor_name;</span><br></pre></td></tr></table></figure><h4 id="1-1-2-4-使用游标"><a href="#1-1-2-4-使用游标" class="headerlink" title="1.1.2.4. 使用游标"></a>1.1.2.4. 使用游标</h4><p>使用fetch into命令将每次fetch到的结果存储到预定义的变量中。这个变量必须是本地变量，不能是用户自定义变量，且这个变量必须定义在游标声明语句之前。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH CURSOR_NAME INTO VAR_NAME;</span><br></pre></td></tr></table></figure><p>一般游标都会在循环结构中使用，下面是在repeat结构中使用游标：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repeat </span><br><span class="line">    fetch ... into ...</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br></pre></td></tr></table></figure><h4 id="1-1-2-5-关闭游标"><a href="#1-1-2-5-关闭游标" class="headerlink" title="1.1.2.5. 关闭游标"></a>1.1.2.5. 关闭游标</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLOSE CURSOR_NAME;</span><br></pre></td></tr></table></figure><p>如果游标没有open，则使用close关闭游标会报错。如果没有显式的关闭游标，游标会在BEGIN…END语句执行结束时自动关闭。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-游标-Cursor&quot;&gt;&lt;a href=&quot;#1-游标-Cursor&quot; class=&quot;headerlink&quot; title=&quot;1. 游标(Cursor)&quot;&gt;&lt;/a&gt;1. 游标(Cursor)&lt;/h2&gt;&lt;p&gt;游标的作用是从一个结果集中逐条获取记录并操作它们。相比sel
      
    
    </summary>
    
    
    
      <category term="MySQL学习笔记" scheme="https://www.infinitasreset.top/tags/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>InnoDb-Architecture</title>
    <link href="https://www.infinitasreset.top/2019/06/19/Innodb-Architecture/"/>
    <id>https://www.infinitasreset.top/2019/06/19/Innodb-Architecture/</id>
    <published>2019-06-19T07:15:34.000Z</published>
    <updated>2024-03-18T02:08:10.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="InnoDB-In-Memory-Structures"><a href="#InnoDB-In-Memory-Structures" class="headerlink" title="InnoDB In-Memory Structures"></a>InnoDB In-Memory Structures</h1><h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><blockquote><p>Buffer Pool 是内存中的一块区域，用于缓存表和索引的数据。通过将频繁访问的数据存储在此</p></blockquote><ul><li>为了加快处理速度，Buffer Pool 允许直接从内存处理常用数据。并且在专用服务器上，高达80%的物理内存都分配给 Buffer Pool。</li><li>为了提高大容量读取操作的效率，Buffer Pool 按页划分，每页可以存储多行。</li><li>为了提高缓存管理的效率，InnoDB 管理 Buffer Pool 使用了 LRU 算法，该算法是用链表实现的。</li><li>Buffer Pool 通过使用变种的 LRU 算法，保证很少被使用缓存及时被移除。</li></ul><h2 id="Buffer-Pool-LRU-Algorithm"><a href="#Buffer-Pool-LRU-Algorithm" class="headerlink" title="Buffer Pool LRU Algorithm"></a>Buffer Pool LRU Algorithm</h2><blockquote><p>LRU(Least Recently Used) 算法，中文叫做最近最少使用算法，这个算法的核心就是淘汰最久未使用的数据。</p></blockquote><h3 id="1、基本的-LRU-算法"><a href="#1、基本的-LRU-算法" class="headerlink" title="1、基本的 LRU 算法"></a>1、基本的 LRU 算法</h3><img src="/2019/06/19/Innodb-Architecture/基本的LRU算法模型.jpg" title="图1:基本的LRU算法模型"><p>LRU 算法是用链表来实现的。</p><ul><li>图 1 的 state1 里，链表的头部是P1， 表示刚刚被访问的数据页。并且假设内存只能放下这么多数据</li><li>然后有一个读请求要访问 P3 数据页，因此变成 state 2，P3 被移到头部。</li><li>state 3 表示，这次访问的数据页是不存在于链表中的，所以需要在 Buffer Pool 中新申请一个数据页 Px，加到链表头部。但是由于内存已经满了，不能申请新的内存。于是，会清空链表末尾 Pm 这个数据页的内存，存入 Px 的内容，然后放到链表头部。</li><li>所以最久未访问的数据页被移除了。</li></ul><p>假设按照这个算法，要全表扫面一个 200G 的表，而这个表是历史数据表，平时没有业务访问它。</p><p>那么按照这个算法扫描的话，就会把当前 Buffer Pool 里数据全部淘汰掉，存入扫描过程中访问到的数据页内容，也就是说 Buffer Pool 里面主要放的是这个历史数据表的数据。</p><p>对于一个正在做业务服务的库，十分不妙。Buffer Pool 的内存命中率会急剧下降，磁盘压力增大，SQL 语句响应变慢。</p><p>所以 InnoDB 不能直接使用这个 LRU 算法，实际上，InnoDB 对 LRU 算法做了改进。</p><h3 id="2、改进的-LRU-算法"><a href="#2、改进的-LRU-算法" class="headerlink" title="2、改进的 LRU 算法"></a>2、改进的 LRU 算法</h3><img src="/2019/06/19/Innodb-Architecture/改进的LRU算法模型.png" title="图2:改进的LRU算法"><p>InnoDB 按照 5:3 的比例把整个 LRU 链表分为了 young 区域和 old 区域。图中 LRU_old 指向的就是 old 区域的第一个位置，是整个链表的 5/8 处。也就是说靠近链表头部的 5/8 是 young 区域，靠近链表尾部的 3/8 是 old 区域。</p><ul><li>图 2 中的 state 1，要访问数据页 P3，由于 P3 在young 区域，因此和优化前的 LRU 算法一致，将其移到头部，编程 state 2。</li><li>之后要访问一个新的不存在当前链表的数据页，这时候依然是淘汰掉数据页 Pm，但新插入的数据页 Px，放在 LRU_old 处</li><li>处于 old 区域的数据页，每次被访问的时候都要做下面这个判断：<ul><li>若这个数据页在 LRU 链表中存在的时间超过了 1s，就把它移动到链表头部；</li><li>若这个数据页在 LRU 链表中存在的时间短于 1s，位置保持不变。1s 这个时间，由参数 innodb_old_blocks_time 控制的。其默认值是 1000，单位毫秒。</li></ul></li></ul><p>这个策略，就是为了处理类似全表扫描的操作量身定制的。以扫描 200G 的历史数据表为例，改进后的 LRU 算法的操作逻辑如下：</p><ul><li>扫描过程中，需要新插入的数据页，都被放到 old 区域；</li><li>一个数据页有多条记录，这个数据页会被多次访问到，但由于是顺序扫描，这个数据页第一次被访问和最后一次被访问的时间间隔不会超过 1s，因此会被保留在 old 区域；</li><li>再继续扫描后续的数据，之前的这个数据页之后也不会再被访问到，于是始终没有机会移到链表头部 (也就是 young 区域)，很快就会被淘汰出去。</li></ul><p>所以这个策略最大的收益，就是在扫描大表的过程中，虽然也用到了 Buffer Pool， 但是对 young 区域完全没有影响，从而保证了 Buffer Pool 响应正常业务的查询命中率。</p>]]></content>
    
    <summary type="html">
    
      关于InnoDB结构的知识
    
    </summary>
    
    
    
      <category term="MySQL学习笔记" scheme="https://www.infinitasreset.top/tags/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>order_by执行流程</title>
    <link href="https://www.infinitasreset.top/2019/04/09/order-by%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.infinitasreset.top/2019/04/09/order-by%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</id>
    <published>2019-04-09T02:46:00.000Z</published>
    <updated>2024-03-18T02:08:10.106Z</updated>
    
    <content type="html"><![CDATA[<p>假设有个表如下定义：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TABLE <span class="symbol">`t`</span> (</span><br><span class="line"><span class="symbol">`id`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="symbol">`city`</span> varchar(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="symbol">`name`</span> varchar(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="symbol">`age`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="symbol">`addr`</span> varchar(<span class="number">128</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (<span class="symbol">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="symbol">`city`</span>(<span class="symbol">`city`</span>)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><p>此时有条 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span> ;</span><br></pre></td></tr></table></figure><p>执行这条 SQL 语句可能存在两种排序，分别是全字段排序和 rowid 排序。</p><h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>为避免全表扫描，需要在 city 字段增加索引。</p><p>explain 命令查看这个语句的执行情况。</p><img src="/2019/04/09/order-by执行流程/explain.png" width="600" height="50" title="图1使用explain命令查看语句执行情况"><p>根据执行情况发现，Extra 字段中到”Using filesort”表示排序，MySQL 会给每一个线程分配一块内存进行排序，称为 sort_buffer。</p><p>语句执行流程：</p><ol><li>初始化 sort_buffer，确定放入 name、city、age 字段；</li><li>从索引 city 找到第一个满足 city=’杭州’ 的主键；</li><li>到主键 id 取出整行，取 name、city、age 这三个值，存入 sort_buffer 内；</li><li>从索引 city，取下一个主键 id；</li><li>重复步骤3、4，直到不满足查询条件为止；</li><li>对 sort_buffer 中的数据按照字段 name 做快速排序；</li><li>按照排序结果前 1000 行返回给客户端。</li></ol><img src="/2019/04/09/order-by执行流程/全字段排序示意图.jpg" width="600" height="400" title="全字段排序示意图"><p>以上称为<strong>全字段排序</strong>，图中排序的动作可能在内存排序，也可能需要使用外部排序，这取决于排序所需要的内存和参数 sort_buffer_size。</p><p>sort_buffer_size 是 MySQL 为排序开辟的内存的大小。如果排序的数据量大于 sort_buffer_size，排序就在内存中完成，否则不得不利用磁盘临时文件辅助排序。</p><h4 id="确认排序是否使用临时文件的方法"><a href="#确认排序是否使用临时文件的方法" class="headerlink" title="确认排序是否使用临时文件的方法"></a>确认排序是否使用临时文件的方法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开 optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">'enabled=on'</span>;</span><br><span class="line"><span class="comment">/* @a 保存 Innodb_rows_read 的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @a <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, <span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`OPTIMIZER_TRACE`</span>\G</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* @b 保存 Innodb_rows_read 的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 计算 Innodb_rows_read 差值 */</span></span><br><span class="line"><span class="keyword">select</span> @b-@a;</span><br></pre></td></tr></table></figure><p>这个方法通过查看 optimizer_trace 的结果来确认的，可以从 number_of_tmp_files 中查看是否用了临时文件。</p><img src="/2019/04/09/order-by执行流程/全排序的OPTIMIZER_TRACE部分结果.png" title="全排序的 OPTIMIZER_TRACE 部分结果"><p>number_of_tmp_files 表示的是，排序过程中使用的临时文件数。内存放不下的时候，就需要外部排序，外部排序一般采用归并排序。<strong>MySQL 将需要排序的数据分为 12 份，每一份单独排序后存在这些临时文件中。然后将12个有序文件再合成一个大的有序文件。</strong></p><p>如果 sort_buffer_size 超过了需要排序的数据量的大小，number_of_tmp_files 就是 0，表示排序可以直接在内存中完成。</p><p>否则就需要放在临时文件中排序。sort_buffer_size 越小，需要分成的份数越多，number_of_tmp_files 的值就越大。</p><p>examined_rows=4000，表示参与排序的行数是4000行。</p><p>sort_mode 里面的 packed_additional_fields 的意思是排序过程中对字符串做了“紧凑”处理，即使 name 字段的定义是 varchar(16) ，在排序过程中还是要按照实际长度来分配空间的。</p><p>这里需要注意的是，为了避免对结论造成干扰，亿把 internal_tmp_disk_storage_engine 设置成 MyISAM。否则，select @b-@a 的结果会显示为 4001。</p><p>这是因为查询 OPTIMIZER_TRACE 这个表时，需要用到临时表，而 internal_tmp_disk_storage_engine 的默认值是 InnoDB。如果使用的是 InnoDB 引擎的话，把数据从临时表取出来的时候，会让 Innodb_rows_read 的值加 1。</p><h3 id="rewid-排序"><a href="#rewid-排序" class="headerlink" title="rewid 排序"></a>rewid 排序</h3><p>全字段排序只对原表读了一遍，剩下的操作都在 sort_buffer 和临时文件执行。因此有个问题，如果查询要返回的字段很多的话，那么 sort_buffer 里放的字段太多，同时能容纳的行数就很少，要分成很多个临时文件，排序性能就很差。</p><p>所以单行过大，效率就不好。那么如果单行过大，MySQL应该怎么处理呢？</p><p>可以通过修改参数，让 MySQL 换一个算法。<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> max_length_for_sort_data <span class="comment">= 16</span></span><br></pre></td></tr></table></figure></p><p>max_length_for_sort_data，是 MySQL 中专门控制用于排序的行数据的长度的一个参数(默认值为1024)。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</p><p>city、name、age 这三个字段的定义总长度是 36，把 max_length_for_sort_data 设置为 16，则新的算法放入 sort_buffer 排序的字段只有 name 和 主键 id。</p><p>由于排序结果少了 city、name 字段，就不能直接返回了。因此整个执行流程变成以下这个样子：</p><ol><li>初始化 sort_buffer，放入 name、id 字段；</li><li>从索引 city 找到第一个满足 city=’杭州’ 的主键；</li><li>到主键 id 取出整行，取 name、id  这两个值，存入 sort_buffer 内；</li><li>从索引 city，取下一个主键 id；</li><li>重复步骤3、4，直到不满足查询条件为止；</li><li>对 sort_buffer 中的数据按照 name 排序；</li><li>遍历排序结果，取前 1000 行数据，并按照 id 值，从原表中取出 city、name 和 age 三个字段返回给客户端。</li></ol><p>这就是 <strong>rewid 排序</strong> ，示意图如下：<br><img src="/2019/04/09/order-by执行流程/rewid排序.jpg" width="600" height="400" title="rewid排序s"></p><p><strong>对比全字段排序，rewid 排序多访问了一次表的主键索引。</strong></p><p>“结果集”是一个逻辑概念，实际上 MySQL 服务端从排序后的 sort_buffer 中依次取出 id，然后到原表查到 city、name 和 age 这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。</p><h4 id="执行-select-b-a-的结果"><a href="#执行-select-b-a-的结果" class="headerlink" title="执行 select @b-@a 的结果"></a>执行 select @b-@a 的结果</h4><img src="/2019/04/09/order-by执行流程/rowid排序的OPTIMIZER_TRACE部分输出.png" title="rowid排序的OPTIMIZER_TRACE部分输出"><ul><li>examined_rows 还是 4000，表示排序的行数是 4000，但是 @b-@a的结果为 5000。</li><li>因为这时候除了排序，还去原表取了 1000 行，所以多读了 1000 行。</li><li>sort_mode 变成了 &lt;sort_key, rowid&gt;，表示参与排序的只有 name 和 id 这两个字段。</li><li>number_of_tmp_files 变成 10 了，是因为这时候参与排序的行数虽然仍然是 4000 行，但是每一行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了。</li></ul><h3 id="全字段排序-VS-rewid-排序"><a href="#全字段排序-VS-rewid-排序" class="headerlink" title="全字段排序 VS rewid 排序"></a>全字段排序 VS rewid 排序</h3><p>如果 MySQL 担心内存太小，会影响排序效率，就会采用 rewid 排序。这样排序过程中一次可以排序更多行，但是需要去原表取数据。</p><p>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放在 sort_buffer 中，这样排序后直接从内存返回数据，不需要再去原表取数据。</p><p>这体现了 MySQL 的一个设计思想：<strong>如果内存够，就要多使用内存，减少磁盘访问。</strong></p><p>对于 InnoDB 表来说，<strong>rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</strong></p><p><strong>可见 MySQL 排序是一个成本比较高的操作。但是并不是所有的 order by 语句都需要排序操作的。MySQL 只所以需要生成临时表，并且在临时表上做排序操作，其原因是原来的数据是无序的。</strong></p><p>如果保证从 city 这个索引的行，天然保持按 name 字段递增排序，就可以不用再排序了。</p><p>如果在表上创建一个 city 和 name 的联合索引：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user(city, <span class="keyword">name</span>);</span><br></pre></td></tr></table></figure></p><img src="/2019/04/09/order-by执行流程/city和name联合索引.png" width="600" height="400" title="city和name联合索引"><p>在这个索引中，依然可以使用树搜索的方式去定位到第一个满足 city=”杭州”的记录，并且确保了接下来按顺序去取下一条记录遍历中，只要 city 的值是杭州，name 就一定是有序的。</p><p>查询流程如下：</p><ol><li>从索引 (city,name) 找到第一个满足 city=’杭州’条件的主键 id；</li><li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回；</li><li>从索引 (city,name) 取下一个记录主键 id；</li><li>重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’杭州’条件时循环结束</li></ol><img src="/2019/04/09/order-by执行流程/引入(city,name)联合索引.jpg" width="600" height="400" title="引入(city,name)联合索引"><p>可以看出这个查询，不需要临时表，不需要排序<br><img src="/2019/04/09/order-by执行流程/explain2.png" width="600" height="60" title="引入(city,name)联合查询explain执行计划"></p><p>从图中可以看到，Extra 字段中没有 Using filesort 了，也就是不需要排序了。而且由于 (city,name) 这个联合索引本身有序，所以这个查询也不用把 4000 行全都读一遍，只要找到满足条件的前 1000 条记录就可以退出了。也就是说，在我们这个例子里，只需要扫描 1000 次。</p><p><strong>利用覆盖索引继续优化</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user_age(city, <span class="keyword">name</span>, age);</span><br></pre></td></tr></table></figure></p><p>查询流程如下：</p><ol><li>从索引 (city,name,age) 找出满足第一个满足 city=’杭州’ 条件的记录，取出 city、name 和 age 三个字段的值，作为结果集的一部分直接返回；</li><li>从索引 (city,name,age) 取下一个记录，同样取出这三个字段的值，作为结果集的一部分返回；</li><li>重复执行步骤 2，直到不满足条件或者查到第 1000 条记录为止。</li></ol><img src="/2019/04/09/order-by执行流程/引入(city,name,age)联合索引后，查询语句的执行流程.jpg" width="600" height="400" title="引入(city,name,age)联合索引后 查询语句的执行流程"><img src="/2019/04/09/order-by执行流程/引入(city,name,age)联合索引后，查询语句的执行计划.png" width="600" height="60" title="引入(city,name,age)联合索引后 查询语句的执行计划"><p>Extra 字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设有个表如下定义：&lt;/p&gt;
&lt;figure class=&quot;highlight n1ql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/spa
      
    
    </summary>
    
    
    
      <category term="MySQL45讲学习笔记" scheme="https://www.infinitasreset.top/tags/MySQL45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Count执行原理</title>
    <link href="https://www.infinitasreset.top/2019/03/25/Count%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>https://www.infinitasreset.top/2019/03/25/Count%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</id>
    <published>2019-03-25T03:46:00.000Z</published>
    <updated>2024-03-18T02:08:10.099Z</updated>
    
    <content type="html"><![CDATA[<p>不同的引擎有不同的实现方式：</p><ul><li>MyISAM 引擎把一个表的总行数放在磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高。(如果加了过滤条件，也不能返回这么快)</li><li>InnoDB 引擎需要把数据一行一行的读取出来，然后累积计数。</li></ul><p>InonoDB引擎由于多版本并发控制的原因，每一行都要判断自己是否对这个会话可见，所以 InnoDB 表只能把数据一行一行读出依次判断。</p><p>MySQL 在执行 count(*) 的时候做了优化。InnoDB 是索引组织表，主键索引树的叶子结点是数据，而普通索引树的叶子结点是主键值。所以普通索引树比主键索引树小很多，因此 MySQL 优化器会找到最小的那颗树来遍历。<strong>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</strong></p><p>除了 count(*)，使用 “show table status” 命令可以通过 TABLE_ROWS 拿到当前表总行数，但是这个字段是通过采样估算来的，不准确。</p><h2 id="统计计数的方法"><a href="#统计计数的方法" class="headerlink" title="统计计数的方法"></a>统计计数的方法</h2><h3 id="一、用缓存系统保存计数"><a href="#一、用缓存系统保存计数" class="headerlink" title="一、用缓存系统保存计数"></a>一、用缓存系统保存计数</h3><p>可以使用 redis 服务存储计数。但是用 redis 有两个问题。一是由于redis数据是存在内存里，异常重启可能会丢失更新；二是即使 redis 正常工作，这个值在逻辑上还是不准确的。</p><p>假设有一个页面，需要显示操作记录的总数，还要显示最近操作的一百条记录。那么这个页面需要先到 Redis 里面取出计数，再到数据表里面取出数据。</p><p>以下两种情况逻辑上必然不准确：</p><ol><li>查到的 100 行结果里面有最新插入的记录，而 Redis 的计数还没加1。</li><li>查到的 100 行结果里没有最新插入的记录，而 Redis 的计数已经加了1。</li></ol><img src="/2019/03/25/Count执行原理/redis不准确时序图.png" title="redis不准确时序图"><p>上图可以看出，会话 B 的读操作在T3时刻执行的，由于 redis 还没有加1，但是已经读到最新插入的记录，所以数据是不一致的。</p><p>在并发系统里面，无法精确控制不同线程的执行时刻，因为存在图中的这种操作序列，所以即使 Redis 正常工作，这个计数值还是逻辑上不准确。导致数据不一致的根本原因，<strong>是由于两个不同的存储系统构成的系统，不支持分布式事务，无法拿到精准一致的视图。</strong></p><p>所以如果要求计数值百分百准备，最好不要使用缓存系统保存计数。</p><h3 id="二、在数据库保存计数"><a href="#二、在数据库保存计数" class="headerlink" title="二、在数据库保存计数"></a>二、在数据库保存计数</h3><p>直接在数据库建一张计数表(InnoDB引擎)。首先InnoDB引擎可以支持崩溃恢复不丢失数据，然后利用 InnoDB 事务的特性可以解决数据不准确的毛病。</p><p>上图可以看到，会话 B 的读操作仍然是T3时刻执行的，但是因为这时候更新事务还没提交，所以计数+1对会话 B 还不可见。因此会话 B 看到的结果，查计数值和 “最近100条记录” 看到的结果逻辑上是一致的。</p><h2 id="不同的-count-的用法"><a href="#不同的-count-的用法" class="headerlink" title="不同的 count 的用法"></a>不同的 count 的用法</h2><p>count() 的语义。count() 是一个聚合函数，对于返回的结果集，一行一行地判断，如果 count 函数的参数不是 NULL， 累计值就加1，否则不加。最后返回累计值。</p><p>所以，count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数”字段”不为 NULL 的总个数。</p><p>分析性能差距的原则：</p><ol><li>server 层要什么给什么</li><li>InnoDB 只给必要的值</li><li>现在的优化器只优化了 count(*) 的语义为”取行数”，其他”显而易见”的优化并没有做。</li></ol><p><strong>对于 count(主键 id)</strong>。  InnoDB 会遍历整张表，把每一行的 id 拿出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p><p><strong>对于 count(1) 来说</strong>。InnoDB 会遍历整张表，但不取值。server 层对返回的每一行，放一个数字 1 进去，判断是不可能为空的，按行累加。</p><p><strong>对于 count(字段)</strong>。 </p><ul><li>如果这个字段定义为”not null”，一行行从记录里面读出这个字段，判断不能为 null，按行累加。</li><li>如果这个字段定义为”null”，那么执行的时候，判断有可能是 null，还要把值取出来再判断一下不是 null 才累加。</li></ul><p><strong>对于 count(*)</strong>。并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</p><p> <strong>所以结论是：按照效率排序的话，count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)，尽量使用 count(*)。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不同的引擎有不同的实现方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MyISAM 引擎把一个表的总行数放在磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高。(如果加了过滤条件，也不能返回这么快)&lt;/li&gt;
&lt;li&gt;InnoDB 引擎需要把数据一行一行的读取出来，然后
      
    
    </summary>
    
    
    
      <category term="MySQL45讲学习笔记" scheme="https://www.infinitasreset.top/tags/MySQL45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据库表的空间回收</title>
    <link href="https://www.infinitasreset.top/2019/03/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E5%9B%9E%E6%94%B6/"/>
    <id>https://www.infinitasreset.top/2019/03/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E5%9B%9E%E6%94%B6/</id>
    <published>2019-03-17T02:27:30.000Z</published>
    <updated>2024-03-18T02:08:10.109Z</updated>
    
    <content type="html"><![CDATA[<p>一个 InnoDB 表包含两部分，即：表结构定义和数据。MySQL 8.0 版本以前，表结构是存在以 .frm 为后缀的文件里，而 8.0 版本 已经允许把表结构定义放在系统数据表中了。</p><h3 id="为什么简单地删除表数据达不到表空间回收的效果"><a href="#为什么简单地删除表数据达不到表空间回收的效果" class="headerlink" title="为什么简单地删除表数据达不到表空间回收的效果"></a>为什么简单地删除表数据达不到表空间回收的效果</h3><h4 id="表数据存放在哪里"><a href="#表数据存放在哪里" class="headerlink" title="表数据存放在哪里"></a>表数据存放在哪里</h4><p>表数据可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 innodb_file_per_table 控制的：</p><ol><li>这个参数设为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li><li>这个参数设为 ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。</li></ol><p>从 MySQL 5.6.6 版本开始，它的默认值就是 ON。将 innodb_file_per_table 设为 ON 是推荐做法。因为，一个表单独存储为一个文件更容易管理，而且在不需要这个表的时候，通过 drop table 命令，系统就会直接删除这个文件。而如果放在共享表空间中，即便表删掉了，空间也是不会回收的。</p><h4 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h4><p>InnoDB 里的数据都是用 B+ 树的结构组织的。如下图所示：</p><img src="/2019/03/17/数据库表的空间回收/B+树索引示意图.png" title="图1B+树索引示意图"><p>假设要删除图 1 中 R4 这个记录，InnoDB 引擎只会把 R4 这个记录标记为删除。如果之后再插入一个 ID 在 300 和 600 之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</p><p>由于 InnoDB 引擎的数据是按页存储的，如果我们删除一个数据页上的所有记录，整个数据页就可以被复用了。</p><p><strong>但是数据页跟记录的复用是不同的</strong></p><ul><li>记录的复用，只限于符合范围条件的数据。比如图 1 R4 被删除后，如果插入一个 ID=400 的行，可以复用这个位置的空间。但是如果插入的是 ID=800 的行，则不能复用这个位置了。</li><li>当整个页从 B+ 树摘掉以后，可以复用到任何位置。以图 1 为例，如果将数据页 page A 上的所有记录删除以后，page A 会被标记为复用。如果此时插入一条 ID=50 的记录需要使用新页的时候，page A 是可以被复用的。</li><li>如果相邻的两个数据页利用率较小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。</li></ul><p><strong>因此如果用 delete 命令把整个表的数据删除，所有的数据页都会被标记可复用，但是磁盘上文件不会变小。</strong></p><p>这些可复用的，但是没有被使用的空间，看起来像是“空洞”。</p><p><strong>实际上，不止是删除数据会造成空洞，插入数据也会。</strong></p><p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，还可能造成索引的数据页分裂。</p><img src="/2019/03/17/数据库表的空间回收/插入数据导致页分裂.png" title="图2 插入数据导致页分裂"><p>从图 2 可以看到，由于 page A 满了，再插入一个 ID=550 的数据时，就不得不再申请一个新的页面 page B 来保存数据。页分裂完成后，page A 的末尾就留下了空洞。</p><p>另外更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。这也会造成空洞。</p><p>所以经过大量增删改查的表，都是有可能存在空洞的。如果能把这些空洞去掉就能达到收缩表空间的目的。</p><h4 id="重建表的方式"><a href="#重建表的方式" class="headerlink" title="重建表的方式"></a>重建表的方式</h4><p><strong>alter table A engine=InnoDB 命令来重建表</strong>。这个命令的执行流程相当于新建一个与表 A 结构相同的表 B，然后按照主键 ID 的顺序，一行一行的从表A 读出来再插入到表 B 中。MySQL 会自动完成转存数据、交换表名、删除旧表的操作。</p><img src="/2019/03/17/数据库表的空间回收/改锁表DDL.png" title="图3改锁表DDL"><p>显然花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写到表 A，就会造成数据丢失。因此整个 DDL 过程中，表 A 中不能有更新，也就是说这个 DDL 不是 Online 的。</p><p><strong>在 MySQL 5.6 版本开始引入 Online DDL，对这个操作流程做了优化。</strong></p><p>流程如下：</p><ol><li><p>建立一个临时文件，扫描表 A 主键的所有的数据页；</p></li><li><p>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</p></li><li><p>生成临时文件的过程中，将所有对 A 的操作记录记录在一个日志文件 (row log) 中，对应的是图中 state2 的状态；</p></li><li><p>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对用的是图中 state3 的状态；</p></li><li><p>用临时文件替换表 A 的数据文件。</p><img src="/2019/03/17/数据库表的空间回收/OnlineDDL.png" title="图4OnlineDDL"></li></ol><p>与图 3 过程的不同之处在于，由于日志文件记录和重放操作这个功能存在，这个方案在重建表的过程中，允许对表 A 做增删改查，这就是 Online DDL。</p><p>需要注意的是 alter 语句在启动的时候需要获取 MDL 写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。退化的目的，是为了实现 Online，MDL 读锁不会阻塞增删改查操作。</p><p>那为什么不直接解锁呢，那是为了保护自己，禁止其他线程同时对这个表做 DDL 。</p><p>对于一个大表，最费时间的是操作就是拷贝数据到临时表的过程。这个步骤的执行期间可以接受增删查改。所以相对整个 DDL 过程来说，锁的时间非常短。对于业务来说，就可以认为是 Online 的。</p><p><strong>Onilne 和 inplace</strong></p><p>在图 3 中，把表 A 中的数据导出来的存放位置叫做 tmp_table。这是一个临时表，是在 server 层创建的。</p><p>在图 4 中，根据表 A 重建出来的数据是放在“tmp_file” 里的，这个临时文件是 InnoDB 在内部创建出来的。整个 DDL 过程都在 InnoDB 内部完成。对于 server 层来说，没有把数据挪动到临时表，是一个“原地“操作，所以称之为 “inplace”。</p><p>所以重建表这个语句 alter table t engine=InnoDB 有隐藏意思：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>, ALGORITHM=inplace;</span><br></pre></td></tr></table></figure><p>跟 inplace 对应的就是拷贝表的方式，对应图 3 的操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>, ALGORITHM=copy;</span><br></pre></td></tr></table></figure><p>所以Online 和 inplace 的关系：</p><ul><li>DDL 过程如果是 Online 的，就一定是 inplace 的</li><li>反过来未必。inplace 的 DDL，有可能不是 Online的。截止到 MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引 (SPATIAL index) 就属于这种情况。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果要收缩一个表，只是 delete 掉表里面不用的数据的话，表文件的大小是不会变的，还要通过 alter table 命令重建表，才能达到表文件变小的目的。重建表具备两种实现方式，Online DDL 的方式是可以考虑在业务低峰期使用的，而 MySQL 5.5 及之前的版本，这个命令是会阻塞 DML 的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个 InnoDB 表包含两部分，即：表结构定义和数据。MySQL 8.0 版本以前，表结构是存在以 .frm 为后缀的文件里，而 8.0 版本 已经允许把表结构定义放在系统数据表中了。&lt;/p&gt;
&lt;h3 id=&quot;为什么简单地删除表数据达不到表空间回收的效果&quot;&gt;&lt;a href
      
    
    </summary>
    
    
    
      <category term="MySQL45讲学习笔记" scheme="https://www.infinitasreset.top/tags/MySQL45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>全局锁和表锁</title>
    <link href="https://www.infinitasreset.top/2019/03/15/%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/"/>
    <id>https://www.infinitasreset.top/2019/03/15/%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/</id>
    <published>2019-03-15T08:49:05.000Z</published>
    <updated>2024-03-18T02:08:10.106Z</updated>
    
    <content type="html"><![CDATA[<p>根据加锁的范围，MySQL 分为全局锁、表级锁和行锁三类。</p><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是针对整个数据库实例加锁。</p><p>MySQL 提供加全局读锁的方法：Flush tables with read lock(FTWRL)。</p><p>解锁的方法：unlock tables</p><p>这个命令可以使整个库处于只读状态，而数据更新语句，数据定义语句和更新类事务的提交语句将全部被阻塞。</p><p>典型使用场景：做全库逻辑备份。</p><p>全库只读的<strong>风险：</strong></p><ul><li>如果在主库备份，备份期间都不能执行更新，业务基本停止。</li><li>如此在从库备份，备份期间从库不能执行主库同步过来的 binlog ，会导致主从延迟。</li></ul><p>使用官方自带的逻辑备份工具 mysqldump，只要加上参数 <strong>–single-transaction</strong>，导数据前会启动一个事务，来确保拿到一致性视图，由于 MVVC 的支持，这个过程中可以正常更新。<strong>一致性读确实很好，但前提必须引擎要支持这个隔离级别</strong>。比如，对于 MyISAM 这种不支持事务的引擎，只能使用 FTWRL 。</p><p><strong>所以，single-transaction 方法只适合所有的表使用事务引擎的库。</strong></p><p>使用 set global readonly=true 也可以让全库进入只读状态。<strong>但是还是不推荐使用，原因如下：</strong></p><ul><li>有些系统，readonly 的值被用来做其他逻辑。例如，用来判断一个库是主库还是从库。因此修改 global 变量影响更大，不建议使用。</li><li>在异常处理机制有差异。如果执行 FTWRL 命令后客户端发送异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设为 readonly 之后，如客户端发送异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li></ul><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级别的锁有两种：一种是表锁，一种是元数据锁 (meta data lock, MDL)</p><h4 id="表锁-lock-tables-…-read-write"><a href="#表锁-lock-tables-…-read-write" class="headerlink" title="表锁 (lock tables … read/write)"></a>表锁 (lock tables … read/write)</h4><p>可以使用 unlock tables 主动解锁，也可以在客户端断开的时候自动释放。lock tables 语法除了会限制别的线程读写外，也限定了本线程接下来的操作对象。</p><p>在没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面很大。</p><h4 id="MDL-锁"><a href="#MDL-锁" class="headerlink" title="MDL 锁"></a>MDL 锁</h4><p>MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保持读写的正确性。可以想象一下，如果一个查询在遍历一个表中的数据，执行期间另一个线程对这个表结构做变更，删除一列，那么多拿到的结果对不上，肯定不行。</p><p>因此，在 MySQL 5.5 版本引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当对表做结构变更的时候，加 MDL 写锁。</p><ul><li>读锁之间不互斥，可多线程同事对一张表之间增删改查</li><li>读写锁之间，写锁之间互斥，用来保证变更表结构操作的安全性。所以如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul><p><strong>ＭDL 锁有一个机制，MDL 会直到事务提交才释放，在做表结构变更的时候，可能会一不小心锁住线上查询和更新</strong>。</p><p>假设我们有个表 t，我们要做如下操作：</p>   <img src="/2019/03/15/全局锁和表锁/MDL死锁操作.jpg" title="MDL死锁操作"><p>由图可知：</p><ul><li>session A 先启动，这时会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行</li><li>session C 会被 blocked，因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁。</li><li>如果在 session C 之后还要对表t新申请 MDL 读锁的请求，会被 session C 阻塞。这就导致整个表都被锁住了，等于这个表完全不可读写了。</li><li>如果某个表上的查询语句频繁，而且客户端有重制机制，这个库的线程很快就会爆满。</li></ul><p><strong>那么怎么给一个小表加字段呢？</strong></p><ul><li><p>先解锁长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，可以查到当前执行的事务。如果要做 DDL 变更刚好有长事务执行，可以考虑先暂停 DDL, 或者 kill 掉这个长事务。</p></li><li><p>假设是个热点表，请求频繁。可以在 alter table 语句设置等待时间，如果在指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员再通过重试命令重复这个过程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">NOWAIT</span> <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">WAIT</span> N <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据加锁的范围，MySQL 分为全局锁、表级锁和行锁三类。&lt;/p&gt;
&lt;h3 id=&quot;全局锁&quot;&gt;&lt;a href=&quot;#全局锁&quot; class=&quot;headerlink&quot; title=&quot;全局锁&quot;&gt;&lt;/a&gt;全局锁&lt;/h3&gt;&lt;p&gt;全局锁就是针对整个数据库实例加锁。&lt;/p&gt;
&lt;p&gt;MySQ
      
    
    </summary>
    
    
    
      <category term="MySQL45讲学习笔记" scheme="https://www.infinitasreset.top/tags/MySQL45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>刷脏页机制</title>
    <link href="https://www.infinitasreset.top/2019/03/13/%E5%88%B7%E8%84%8F%E9%A1%B5%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.infinitasreset.top/2019/03/13/%E5%88%B7%E8%84%8F%E9%A1%B5%E6%9C%BA%E5%88%B6/</id>
    <published>2019-03-13T02:00:25.000Z</published>
    <updated>2024-03-18T02:08:10.109Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是脏页？"><a href="#什么是脏页？" class="headerlink" title="什么是脏页？"></a>什么是脏页？</h3><p>InnoDb 在执行更新语句的时候，是先写日志(redo log)，再更新内存，然后告诉客户端更新完成了。此时内存和磁盘的数据是不一致的。<br><strong>所以当内存数据页跟磁盘数据页不一致的时候，称这个内存也为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容一致的时候，称之为“干净页”</strong>。</p><h3 id="什么时候刷脏页？"><a href="#什么时候刷脏页？" class="headerlink" title="什么时候刷脏页？"></a>什么时候刷脏页？</h3><p>将内存上的数据写入到磁盘，称为刷脏页(flush)。</p><p>以下 MySQL 可能刷脏页的时机：</p><ol><li><p>InnoDB redo log 写满了。这时候系统会停止所有的更新操作，把 checkpoint 往前推进，redo log 留出空间继续写。下图展示了 checkpoint 从 CP 推进到 CP’，需要将两点的日志，对应的脏页全部 flush 到磁盘上。</p><img src="/2019/03/13/刷脏页机制/redolog状态图.jpg" title="redolog状态图"></li><li><p>系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。但不会直接淘汰内存，因为刷脏页必定写盘，写盘就保证了数据页只有两种状态：</p><ul><li>一种是内存里存在，内存里肯定是最正确的结果，直接返回</li><li>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。这样效率最高。</li></ul></li><li><p>MySQL 认为系统“空闲”的时候。MySQL 会利用空闲时间刷脏页，见缝插针。</p></li><li><p>MySQL 正常关闭的时候。这时 MySQL 会将所有的脏页都 flash 到磁盘上，这样下次启动 MySQL 的时候，就可以直接从磁盘读取数据，启动速度会很快。</p></li></ol><p><strong>四种场景对性能的影响</strong></p><ul><li><p>第一种 “redo log 写满了，要 flush 脏页”。这种情况 InnoDB要尽量避免的。因为这出现这种情况的时候，整个系统都不能再接受更新了，所有的更新必须堵住。</p></li><li><p>第二种 ”内存不够用了，要先将脏页写进磁盘“。这种情况是常态。<strong>InnoDB 用缓冲池 (buffer pool) 管理内存，缓冲池中的内存页有三种状态：</strong></p><ul><li>第一种，还没有使用</li><li>第二种，使用了并且是干净页</li><li>第三种，使用了并且是脏页</li></ul><p>InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。</p><p>当要读入的数据页没有在内存的时候，就必须要缓冲池申请一个数据页。这时候只能将最久不使用的数据页从内存中淘汰掉；如果是要淘汰一个干净页，就直接释放出来复用；但如果是脏页，就必须将脏页先刷到磁盘，变成干净页才能复用。</p><p>所以刷脏页虽然是常态，但是出现以下两种情况，都是会明显影响性能的：</p><ol><li>一个查询要淘汰的脏页过多，会导致查询的响应时间明显变长。</li><li>日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务是不能接受的。</li></ol><p>所以需要有控制脏页比例的机制，来避免以上两种情况。</p></li></ul><h3 id="InnoDB-刷脏页的控制策略"><a href="#InnoDB-刷脏页的控制策略" class="headerlink" title="InnoDB 刷脏页的控制策略"></a>InnoDB 刷脏页的控制策略</h3><ol><li><p>正确告诉 InnoDB 所在主机的 IO 能力。通过设置 innodb_io_capacity 参数，告诉 InnoDB 磁盘能力。这个值建议设置为磁盘的 IOPS。可以使用 fio 工具测试磁盘的随机读写的能力。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio <span class="attribute">-filename</span>=<span class="variable">$filename</span> <span class="attribute">-direct</span>=1 -iodepth 1 -thread <span class="attribute">-rw</span>=randrw <span class="attribute">-ioengine</span>=psync <span class="attribute">-bs</span>=16k <span class="attribute">-size</span>=500M <span class="attribute">-numjobs</span>=10 <span class="attribute">-runtime</span>=10 -group_reporting <span class="attribute">-name</span>=mytest</span><br></pre></td></tr></table></figure></li><li><p>控制 InnoDB 刷盘速度。InnoDB 是根据脏页比例、redo log 写盘速度来控制刷脏页的速度。</p><p>InnoDB 会根据两个因素单独先算出两个数字。</p><p>参数 innodb_max_dirty_pages_pct 是脏页比例上限，默认值是 75% 。InnoDB 会根据当前的脏页比例 (假设为M) ，算出一个范围在0~100之间的数组，计算这个数据伪码如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">      <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，假设为N。</p><p>InnoDB 会根据 N 算出在 0~100的数字，这个计算公式记为 F2(N)。F2(N) 算法复杂，但是 N 越大，算出来的值越大。</p><p><strong>然后，根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R ，之后引擎可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制脏页的速度。</strong></p></li></ol><p>InnoDB 会在后台刷脏页，而刷脏页的过程是将内存页写入磁盘。所以无论是查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用 IO 资源并可能影响到更新语句，都可能造成从业务端感知数据库突然变慢。</p><p><strong>要尽量合理避免这种情况，就要合理设置 Innodb_io_capacity 的值，并且平时要多关注脏页比例，不要让它接近于 75%</strong></p><p>脏页比例是通过 Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total 得到的，具体代码如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @a <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME = <span class="string">'Innodb_buffer_pool_pages_dirty'</span>;</span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME = <span class="string">'Innodb_buffer_pool_pages_total'</span>;</span><br><span class="line"><span class="keyword">select</span> @a/@b;</span><br></pre></td></tr></table></figure><p><strong>“连坐”策略</strong></p><p>InnoDB 在刷脏页的时候，如果发现当前数据页旁边的那个数据页也是脏页，就会连带着一起刷掉；这种情况会蔓延，如果邻居的邻居也是脏页，也会一起刷。</p><p>在 InnoDB 中，Innodb_flush_neighbors 参数可以控制该行为，值为1的时候会有上述”连坐”机制，值为0的时候表示自己刷自己的，不帮邻居刷了。</p><p>找“邻居”这种行为，在机械硬盘时代很有意义，可以减少很多随机IO。现在如果使用 SSD 或者 IOPS 比较高的设备，建议将 Innodb_flush_neithbors 设为0，在 MySQL 8.0 已经默认为 0。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是脏页？&quot;&gt;&lt;a href=&quot;#什么是脏页？&quot; class=&quot;headerlink&quot; title=&quot;什么是脏页？&quot;&gt;&lt;/a&gt;什么是脏页？&lt;/h3&gt;&lt;p&gt;InnoDb 在执行更新语句的时候，是先写日志(redo log)，再更新内存，然后告诉客户端更新完成了。此
      
    
    </summary>
    
    
    
      <category term="MySQL45讲学习笔记" scheme="https://www.infinitasreset.top/tags/MySQL45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-更新语句怎么执行的</title>
    <link href="https://www.infinitasreset.top/2019/03/05/MySQL-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>https://www.infinitasreset.top/2019/03/05/MySQL-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/</id>
    <published>2019-03-05T09:56:41.000Z</published>
    <updated>2024-03-18T02:08:10.102Z</updated>
    
    <content type="html"><![CDATA[<p>假设有个表T，创建语句如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table <span class="constructor">T(ID <span class="params">int</span> <span class="params">primary</span> <span class="params">key</span>, <span class="params">c</span> <span class="params">int</span>)</span>;</span><br></pre></td></tr></table></figure><p>将 ID=2 这一行的值加2：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">update</span> T <span class="keyword">set</span> c=c+<span class="number">1</span> <span class="keyword">where</span> ID = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><img src="/2019/03/05/MySQL-更新语句怎么执行的/MySQL逻辑架构图.png" title="MySQL逻辑架构图"><p>该语句基本的执行链路如下：</p><ol><li>连接数据库，连接器会处理</li><li>分析器会通过词法和语法分析知道这是一条更新语句</li><li>优化器决定使用 ID 这个索引</li><li>执行器进行具体执行，找到这一行，然后更新</li></ol><p>以上只是基本链路，MySQL 执行更新还涉及两个日志模块，分别是 redolog 和 binlog。</p><h3 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log (重做日志)"></a>redo log (重做日志)</h3><p>在《孔乙己》这篇文章中，酒店掌柜有个专门的黑板来记录客人的赊账记录。如果赊账的人多，他会记在黑板上，如果赊账的人过多，黑板总会记不下，掌柜一定得擦掉黑板，把赊账的记录写入专门记录赊账的记账本。</p><p>如果有人赊账或还帐，掌柜一般有两种做法：</p><ul><li>直接记录在账本上</li><li>先记录在黑板上，等空闲了再记录到账本上</li></ul><p>如果店里的人很多，掌柜还直接记录在账本上，那么效率一定很低，非常耽误生意。因此掌柜肯定会选择第二种做法。</p><p>在 MySQL 中也有这样的问题，如果每次更新操作都需要写进磁盘，然后磁盘也要找到对应的记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决此问题，MySQL设计者就用了类似酒店掌柜黑板的思路来提升更新效率。</p><p>在 MySQL 中，redolog 就充当了黑板的角色，磁盘就是账本的角色。通过先写日志，再写磁盘来提升更新效率。其实这也是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead-Logging。</p><p>具体来将，当有一条记录需要更新的时候：</p><ul><li>InnoDB 引擎先将记录写到 redo log 里面，并更新内存，这个时候就算更新完了</li><li>InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里</li></ul><p>redo log 是固定大小的，比如可以配置成为一组 4 个文件，每个文件大小是 1GB，那么可以记录 4GB 的操作。从头开始写，写到末尾又回到开头循环写。如下图所示。</p><img src="/2019/03/05/MySQL-更新语句怎么执行的/redolog循环写.png" title="redolog循环写"><ul><li>wirte pos 是当前记录的位置，边写边后移，写到 3 号文件末尾后就回到 0 号文件开头。</li><li>checkpoint 是当前要擦除的位置，也是往后移并循环的，擦除记录前要将记录更新到数据文件。</li><li>write pos 和 checkpoint 之间是空着的部分，可以用来记录新的操作。</li><li>如果 write pos 追上了 checkpoint，表示 redo log 满了，这时候不能执行新的更新，得停新来先擦掉一些记录，把 checkpoint 推进一下。</li></ul><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个叫 <strong>crash-safe。</strong></p><h3 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog (归档日志)"></a>binlog (归档日志)</h3><p>MySQL 整体看来，其实就两块：</p><ul><li>一块是 Server 层，主要做的是 MySQL 功能层面的事情；</li><li>一块是引擎层，负责存储相关的事宜。</li></ul><p>redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog</p><p>这两种日志有以下三种不同：</p><ul><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有的引擎都可以用。</li><li>redo log 是物理日志，记录的是 “在这个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如 “给 ID=2 这一行的 c 字段加 1”。</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。”追加写” 是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ul><p>所以执行器和 InooDB 引擎在执行简单的 update 语句时内部流程如下。</p><img src="/2019/03/05/MySQL-更新语句怎么执行的/执行update.png" title="执行update"><ol><li>执行器先找到引擎 ID= 2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎借口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告诉执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并将 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交 (commit) 状态，更新完成。</li></ol><p>由上可知，最后是三步将 redo log 的写入拆成了两个步骤：prepare 和 commit。这就是“两阶段提交”。</p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>目的：是为了让两份日志之间的逻辑一致。</p><p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么先写 redo log，要么先写 binlog，会出现以下状况。(仍然用前面的例子)</p><ol><li><p><strong>先写 redo log 后写 binlog。</strong>假设写完了 redo log，binlog 还没写完崩溃，MySQL 异常重启。由于 redo log有崩溃恢复数据的能力，所以恢复后 c 的值仍然是 1 。<br>但是由于 binlog 没写完就 crash 了，这个时候 binlog 里面就没有记录这个语句。因此之后备份日志的时候，存起来的 binlog 没有这条语句。<br>然后如果用这个 binlog 恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原酷的值不同。</p></li><li><p><strong>先写 binlog 后写 redo log。</strong>如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了 “把 c 从 0 改为 1”这个日志。所以之后 binlog 来恢复的时候就多了一个事务，恢复出来的 c 的值就是 1，与原库的值不同。</p></li></ol><p>由上可知，不使用两阶段提交，那么数据库状态有可能和它的日志恢复出来的库状态不一致。<br>redo log 和 binlog 都可以用于表示事务提交的状态，而两阶段提交就是让两个状态保持逻辑上的一致。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设为 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。建议设为 1，可以保证 MySQL 异常重启之后数据不丢失。</li><li>sync_binlog 这个参数设为 1 的时候，表示每次事务的 binlog 都持久化到磁盘。同样建议设为 1，可以保证 MySQL 异常重启后数据不丢失。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设有个表T，创建语句如下：&lt;/p&gt;
&lt;figure class=&quot;highlight reasonml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td cl
      
    
    </summary>
    
    
    
      <category term="MySQL45讲学习笔记" scheme="https://www.infinitasreset.top/tags/MySQL45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-字符串加索引的方法</title>
    <link href="https://www.infinitasreset.top/2019/03/01/MySQL-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E7%B4%A2%E5%BC%95%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://www.infinitasreset.top/2019/03/01/MySQL-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E7%B4%A2%E5%BC%95%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2019-03-01T09:32:33.000Z</published>
    <updated>2024-03-18T02:08:10.099Z</updated>
    
    <content type="html"><![CDATA[<p>假设要维护一个支持邮箱登录的系统，用户表如下定义：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">create</span> table SUser(</span><br><span class="line">ID bigint unsigned <span class="keyword">primary</span> <span class="keyword">key</span>,</span><br><span class="line">email varchar(<span class="number">64</span>), </span><br><span class="line">... </span><br><span class="line">)engine=innodb;</span><br></pre></td></tr></table></figure><p>由于使用邮箱登录，登录的时候一定要根据邮箱去查询。所以业务代码一定会出现一下语句：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> ID, email <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">'zhangssxyz@xxx.com'</span>;</span><br></pre></td></tr></table></figure><p>因此 email 字段必须加上索引，否则这个语句会做全表扫描。</p><h3 id="１．完整索引"><a href="#１．完整索引" class="headerlink" title="１．完整索引"></a>１．完整索引</h3><p>直接给 email 字段加上索引</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alert <span class="keyword">table</span> Suser <span class="comment">add index index1(email)</span>;</span><br></pre></td></tr></table></figure><p>该语句创建的 index1 索引，包含了每个记录的整个字符串，索引示意图如下：</p><img src="/2019/03/01/MySQL-字符串加索引的方法/完整索引.jpg" title="完整索引示意图"><p><strong>index1 执行顺序如下：</strong></p><ul><li>从 index1 索引树找到满足索引值是 <a href="mailto:&#39;zhangssxyz@xxx.com" target="_blank" rel="noopener">&#39;zhangssxyz@xxx.com</a>‘ 的记录，取得 ID2的值；</li><li>到该主键上插到主键值是 ID2 的行，判断 email 的值是正确的，将这行记录加入结果集；</li><li>取 index1 索引树上刚刚查到的位置的下一条记录，发现不满足 <a href="mailto:email=&#39;zhangssxyz@xxx.com" target="_blank" rel="noopener">email=&#39;zhangssxyz@xxx.com</a>‘ 的条件，循环结束。</li></ul><p>这个过程中，只需要回主键索引取一次记录，所以系统只认为扫描了一行。</p><h3 id="２．-前缀索引"><a href="#２．-前缀索引" class="headerlink" title="２． 前缀索引"></a>２． 前缀索引</h3><p>将某个字段的前ｎ位设为索引，下面语句创建 email(6) 索引结构</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alert <span class="keyword">table</span> SUser <span class="comment">add index index2(email(6))</span>;</span><br></pre></td></tr></table></figure><p>该语句创建的 index2 索引，对于每个记录只取了６个字节，索引示意图如下：</p><img src="/2019/03/01/MySQL-字符串加索引的方法/前缀索引.jpg" title="前缀索引示意图"><p><strong>index2 执行顺序如下：</strong></p><ul><li>从 index2 索引树找到满足索引值是 ‘zhangs’ 的记录，找到第一个是 ID1;</li><li>到主键上查到主键值是 ID1 的行，判断 email 的值不是 <a href="mailto:&#39;zhangssxyz@xxx.com" target="_blank" rel="noopener">&#39;zhangssxyz@xxx.com</a>‘，这行丢弃</li><li>取 index2 上刚刚查到的位置的下一条记录，发现仍然是 ‘zhangs’, 取出 ID2，再到 ID 索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li><li>重复上一步，直到在 index2 上取到的值不是 ‘zhangs’ 时，循环结束。</li></ul><p>这个过程中，要回主键索引取 4 次判断，也就是扫描了 4 行。</p><p>通过对比，可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变多。</p><p>但是，对于这个查询语句来说，如果定义的 index2 不是 email(6) 而是 email(7)，也就是说取 email 字段前７个字节来构建索引的话，即满足前桌 ‘zhangs’ 的记录只有一个，也能够直接插到 ID2，只扫描一行就结束了。</p><p>也就是说<strong>使用前缀索引，定义好长度就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p><p><strong>如何确认前缀索引的长度？</strong></p><p>答案：区分度，区分度越高意味着重复值的键值越少。因此可以统计索引有多少不同的值来判断要使用多长的前缀。</p><p>首先，使用下面这个语句，算出这个列上有多少不同的值：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure><p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7 个值字节的前缀索引：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span></span><br><span class="line">true<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email, <span class="number">4</span>) <span class="keyword">as</span> L4)</span><br><span class="line">true<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email, <span class="number">5</span>) <span class="keyword">as</span> L5)</span><br><span class="line">true<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email, <span class="number">6</span>) <span class="keyword">as</span> L6)</span><br><span class="line">true<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email, <span class="number">7</span>) <span class="keyword">as</span> L7)</span><br><span class="line"><span class="keyword">from</span> Suser;</span><br></pre></td></tr></table></figure><p>使用前缀索引很有可能损失区分度，所以需要预先设定一个损失比例，比如 5%。然后在返回的 L4~L7 中，找出不小于 L*95% 的值，假设这里 L6、L7 都满足，可以选择前缀长度为6。</p><p><strong>前缀索引对覆盖索引的影响</strong></p><p>前缀索引不仅仅可能会增加扫描行数，还有可能影响性能。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> id,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email =<span class="string">'zhangssxyz@email.com'</span>;</span><br></pre></td></tr></table></figure><p>以上这个语句仅仅返回 id 和 email 字段。</p><p>所以，如果使用 index1 的话，可以利用覆盖索引，从 index1 查询到结果直接返回即可，无需回到 ID 索引再去查一次。而如果使用 index2 的话，就不得不回到 ID 索引再去判断 email 字段的值。</p><p>即使将 index2 的定义修改为 email(18) 的前缀索引，这时候虽然 index2 包含了所有的信息，但是 InnoDB还是要回到 ID 索引再查一次，因为系统并不确定前缀索引的定义是否截断了完整信息。</p><p>也就是说，<strong>使用前缀索引就用不上覆盖索引对查询性能的优化。</strong></p><h3 id="3-其他方式"><a href="#3-其他方式" class="headerlink" title="3. 其他方式"></a>3. 其他方式</h3><p>对于邮箱这样的字段来说，使用前缀索引的效果可能还不粗，但是遇到前缀的区分度不够好的情况，该怎么办？</p><p>比如，身份证号码，共 18 位，其中前 6 位是地址码，所以同一个县的人身份证号前6位一般是相同的，因此如果对身份证号做长度为6的前缀索引，区分度极低。</p><p>按照前面的方法，可能需要创建长度为12以上的前缀索引，才能满足区分度要求。但是索引选取的越长，占用的磁盘空间越大，相同的数据页能放下的索引的值越少，搜索效率也越低。</p><p>那么如果确认业务需求只按照身份证号进行等值查询的需求，可以使用以下方法</p><p><strong>第一种倒序存储</strong> (如果存储身份证号码的时候把它倒过来存，每次查询可以这么写)</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card = <span class="keyword">reverse</span>(<span class="string">'input_id_card_string'</span>);</span><br></pre></td></tr></table></figure><p>由于身份证最后6位没有地址码这样重复的逻辑，最后6位很有可能提供了足够的区分度，</p><p><strong>第二种使用 hash 字段</strong> (在表上再创建一个整数字段，来保存身份证的校验码，同事在这个字段上创建索引)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> id_card_crc <span class="type">int</span> unsigned, <span class="keyword">add</span> <span class="keyword">index</span>(id_card_crc);</span><br></pre></td></tr></table></figure><p>然后每次插入新记录的时候，都使用 crc32() 这个函数得到校验码填到这个新字段，由于校验码可能存在冲突，也就是说两个不同的身份证号通过 crc32() 函数得到的结果可能是相同的，所以查询语句 where 部分要判断 id_card 的值是否精确相同。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select field_list <span class="keyword">from</span> t where <span class="attribute">id_card_crc</span>=crc32('input_id_card_string') <span class="keyword">and</span> <span class="attribute">id_card</span>=<span class="string">'input_id_card_string'</span>;</span><br></pre></td></tr></table></figure><p>这样索引长度变成了 4 个字节，比原来小了很多。</p><p><strong>两种方法的异同点</strong></p><p>同：</p><ul><li>不支持范围查询，只支持等值查询</li></ul><p>异：</p><ul><li>占用空间上，倒序存储方式在主键索引上不会消耗额外的存储空间，而 hash 字段防范需要增加一个字段。</li><li>CPU 消耗方面，倒序方式每次读写，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果从两个函数的计算复杂度来看的话， reverse 函数额外消耗的 CPU 资源会更小点。</li><li>从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行接近1。而倒序存储的方式毕竟还是用的前缀索引的方式，也就是说会增加扫描行数。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>字符串字段创建索引总共有4种方式</p><ol><li>直接创建完整索引，这样可能比较占用空间；</li><li>创建前缀索引，节省空间，但是会增加查询扫描次数，并且不能使用覆盖索引</li><li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题</li><li>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设要维护一个支持邮箱登录的系统，用户表如下定义：&lt;/p&gt;
&lt;figure class=&quot;highlight n1ql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
    
    
      <category term="MySQL45讲学习笔记" scheme="https://www.infinitasreset.top/tags/MySQL45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Inversion of Control</title>
    <link href="https://www.infinitasreset.top/2018/01/03/Inversion-of-Control-Container/"/>
    <id>https://www.infinitasreset.top/2018/01/03/Inversion-of-Control-Container/</id>
    <published>2018-01-03T09:27:22.000Z</published>
    <updated>2024-03-18T02:08:10.099Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC" target="_blank" rel="noopener">Inversion of Control</a> 中文翻译为“控制反转”，是面向对象编程中的一种设计原则。用来降低程序代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中</p></blockquote><h2 id="理解控制反转"><a href="#理解控制反转" class="headerlink" title="理解控制反转"></a>理解控制反转</h2><p>假设有个老板需要一个才华特别好的人帮助他做事，于是直接命令小张帮忙。示例如下。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类 A 需要用到类 B。直觉做法。</span></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">true<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">truetrue$b = <span class="keyword">new</span> B();</span><br><span class="line">truetrue$b-&gt;doSomething();</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">XiaoZhang</span> </span>&#123;</span><br><span class="line">true<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">truetrue<span class="keyword">echo</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老板果然牛逼，老板直接控制小张干活。但是有一点不好的在于，如果小张跑路了咋办呢？为了解决这个问题，老板特地建了一个人才库，由人才库向老板输出人才，来完成事物。</p><p>由此可知：</p><ul><li>老板直接控制小张干活，即在代码中体现为应用程序主动寻求外部资源，应用程序是老大。</li><li>老板等待人才库注入人才。即在代码中 IoC 容器先获取需要的实例，然后再反向注入到应用程序。应用程序被动等待。</li><li>老板由主动转为被动，即为控制反转。</li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于接口实现依赖注入，老板不再依赖小张</span></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">true<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">(niuren $b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">truetrue$b-&gt;doSomething();</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">niuren</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">XiaoZhang</span> <span class="title">implement</span> <span class="title">niuren</span></span>&#123;</span><br><span class="line">true<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">truetrue<span class="keyword">echo</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖查找"><a href="#依赖查找" class="headerlink" title="依赖查找"></a>依赖查找</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用容器等控制系统，主动解析获取对象</span></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">true<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">(B $b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">truetrue$b-&gt;doSomething();</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">XiaoZhang</span> </span>&#123;</span><br><span class="line">true<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">truetrue<span class="keyword">echo</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">true<span class="comment">//获取实例</span></span><br><span class="line">true<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">true<span class="comment">//绑定实例</span></span><br><span class="line">true<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bind</span><span class="params">($abstract, $contern)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$container = <span class="keyword">new</span> Container();</span><br><span class="line">$container-&gt;bind(<span class="string">'xz'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">true<span class="keyword">return</span> <span class="keyword">new</span> XiaoZhang();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$xiaozhang = $container-&gt;get(<span class="string">'xz'</span>);</span><br><span class="line"></span><br><span class="line">$boss = <span class="keyword">new</span> Boss();</span><br><span class="line">$boss-&gt;doSomething($xiaozhang);![]()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上两种方法都是为了代码解耦。</p><ul><li>依赖注入不需要了解自身依赖具体哪个类，只要所依赖的类实现了自身需要的方法即可。</li><li>依赖查找即提供一种调控系统，实现依赖解析、依赖注入、依赖绑定。</li></ul>]]></content>
    
    <summary type="html">
    
      关于控制反转的笔记
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>PHP 自动加载分析</title>
    <link href="https://www.infinitasreset.top/2017/12/21/PHP-Auto-Loader/"/>
    <id>https://www.infinitasreset.top/2017/12/21/PHP-Auto-Loader/</id>
    <published>2017-12-21T06:54:07.000Z</published>
    <updated>2024-03-18T02:08:10.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人主要总结 PHP 自动加载的功能，内容涉及 SPL 函数库，PSR 标准，Composer 自动加载。</p><hr><h3 id="PHP-自动加载功能"><a href="#PHP-自动加载功能" class="headerlink" title="PHP 自动加载功能"></a>PHP 自动加载功能</h3><blockquote><p>自动加载是指，PHP 解释器在运行时按需自动找到并加载 PHP 类的过程。</p></blockquote><h4 id="为什么需要自动加载功能"><a href="#为什么需要自动加载功能" class="headerlink" title="为什么需要自动加载功能"></a>为什么需要自动加载功能</h4><p>PHP5 后，PHP完全支持面向对象编程。在面向对象编程中，开发者必须为每个类都建立一个 PHP 文件。这会带来一个烦恼：每个脚本的开头，都需要包含（include）一个长长的列表（每个类都有个文件）。</p><h4 id="autoload-魔术方法-（PHP-7-2-废止）"><a href="#autoload-魔术方法-（PHP-7-2-废止）" class="headerlink" title="__autoload( ) 魔术方法 （PHP 7.2 废止）"></a>__autoload( ) 魔术方法 （PHP 7.2 废止）</h4><p>为了避免每个类文件都要 include/require 一大串类，PHP5 之后提供了类的自动加载机制(autoloader)。<br>这种加载机制有以下几个优点。</p><blockquote><ol><li>用户可以有需要再加载类，而不是一开始就全部加载进来。</li><li>无需考虑类的文件地址，实现了逻辑与文件分离。</li></ol></blockquote><p>PHP5 后，当加载 PHP 类时，如果类所在的文件没有被包含或类名出错，Zend引擎会自动调用 <a href="http://php.net/manual/zh/function.autoload.php" target="_blank" rel="noopener">__autoload( )</a> 函数来加载。此函数需要用户自己实现。下面是个简单的例子。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//__autoload( ) 使用实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span><span class="params">($className)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">true$fileName = <span class="string">"./"</span> . $className . <span class="string">".php"</span>;</span><br><span class="line">true<span class="keyword">include_once</span>($fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个简单的例子可知，__autoload( ) 函数讲类名和文件名对应起来，两者最重要的是类名和文件的映射规则。</p><h4 id="spl-autoload-register-方法"><a href="#spl-autoload-register-方法" class="headerlink" title="spl_autoload_register( ) 方法"></a>spl_autoload_register( ) 方法</h4><blockquote><p>做项目时我们引入大量的第三方库，每个库都有自己的映射规则。如果要实现自动加载，__autoloader( ) 函数必须实现每条规则，由于函数全局唯一的特性，这将导致函数臃肿、难以维护、容易出错。</p></blockquote><p>为了解决这个问题，PHP 提供了 <a href="http://php.net/manual/zh/function.spl-autoload-register.php" target="_blank" rel="noopener">sql_autoload_register()</a> 函数，该函数支持任意数量的自动加载器，所有的自动加载器都存放在autoload 函数的队列内。当 PHP 找不到类名，PHP 会自动调用这个队列，执行队列内的自定义的 __autoloader() 函数，实现自动加载功能。</p><h4 id="PSR-4-自动加载器策略"><a href="#PSR-4-自动加载器策略" class="headerlink" title="PSR-4 自动加载器策略"></a>PSR-4 自动加载器策略</h4><blockquote><p>PSR 是 PHP Standards Recommendation 的简称。PSR- 开头，后面+一个数字。都是 PHP-FIG 制定的推荐规范，用于解决大多数 PHP 框架经常会遇到的某个具体问题。 PHP 框架无需频繁解决相同的问题，大家只需使用共同的方案解决。</p></blockquote><blockquote><p>如今，现代的 PHP 组件和框架都符合同一个自动加载标准。这意味着我们只需一个自动加载器就能混合搭配多个PHP组件。</p></blockquote><blockquote><p>PSR-4 用于在运行时查找并加载 PHP 类、接口和性状。只建议如何使用文件系统目录结构和 PHP 命名空间组织代码。</p></blockquote><p>PSR-4的精髓是把命名空间的前缀和文件系统中的目录对应起来。举例如下。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设<span class="symbol">\O</span>reilly<span class="symbol">\M</span>odernPHP命名空间中的类在物理文件系统的src/目录中</span><br><span class="line"></span><br><span class="line">"<span class="symbol">\O</span>reilly<span class="symbol">\M</span>odernPHP" =&gt; "src/"</span><br><span class="line"></span><br><span class="line">"<span class="symbol">\O</span>reilly<span class="symbol">\M</span>odernPHP<span class="symbol">\C</span>hapter1<span class="symbol">\E</span>xample" =&gt; "src/Chapter1/Example.php"</span><br><span class="line"></span><br><span class="line">命名空间的前缀可以是顶级命名空间，也可以是顶级命名空间+任意一个子命名空间</span><br></pre></td></tr></table></figure><p>由上可知命名空间前缀对应于文件系统的基目录，命名空间前缀的子命名空间对应这个基目录的子目录。</p><p>接下我们看看PSR-4 自动加载器的示例代码。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line">/**</span><br><span class="line"> * 举例说明如何实现项目专用的自动加载器</span><br><span class="line"> * </span><br><span class="line"> * 使用 SPL 注册这个自动加载函数后，遇到下述代码时这个函数</span><br><span class="line"> * 会尝试从 /path/to/project/src/Baz/Qux.php 文件中加载</span><br><span class="line"> * </span><br><span class="line"> * \Foo\Bar\Baz\Qux 类</span><br><span class="line"> *  new \Foo\Bar\Baz\Qux;     </span><br><span class="line"> *  </span><br><span class="line"> * @param string $class 完全限定的类名</span><br><span class="line"> * @return void</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php">spl_autoload_register(<span class="function"><span class="keyword">function</span> <span class="params">($class)</span> </span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="comment">// 项目的命名空间前缀</span></span></span><br><span class="line"><span class="php">    $prefix = <span class="string">'Foo\\Bar\\'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="comment">// 基目录</span></span></span><br><span class="line"><span class="php">    $base_dir = <span class="keyword">__DIR__</span> . <span class="string">'/src/'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="comment">// 参数传入的类使用这个命名空间前缀吗?</span></span></span><br><span class="line"><span class="php">    $len = strlen($prefix);</span></span><br><span class="line"><span class="php">    <span class="keyword">if</span> (strncmp($prefix, $class, $len) !== <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="php">        <span class="comment">// 不使用交给下一个自动加载器处理</span></span></span><br><span class="line"><span class="php">        <span class="keyword">return</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="comment">// 获取去掉前缀后的类名</span></span></span><br><span class="line"><span class="php">    $relative_class = substr($class, $len);</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="comment">// 把命名空间前缀替换成基目录</span></span></span><br><span class="line"><span class="php">    <span class="comment">// 在去掉前缀的类名中，把命名空间分隔符替换成目录分隔符</span></span></span><br><span class="line"><span class="php">    <span class="comment">// 然后在后面加上.php</span></span></span><br><span class="line"><span class="php">    $file = $base_dir . str_replace(<span class="string">'\\'</span>, <span class="string">'/'</span>, $relative_class) . <span class="string">'.php'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="comment">// 如存在，导入</span></span></span><br><span class="line"><span class="php">    <span class="keyword">if</span> (file_exists($file)) &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">require</span> $file;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;);</span></span><br></pre></td></tr></table></figure><hr><p>以上可知现代 PHP 自动加载策略的实现是由PSR-4 规范 + SPL 函数库共同构建。我们编写的 PSR-4 自动加载器虽然可用，但是我们自己没必要如此做。因为我们可以使用依赖管理器 Composer 自动生成的 PSR-4 自动加载器。</p>]]></content>
    
    <summary type="html">
    
      关于 PHP 自动加载的笔记
    
    </summary>
    
    
    
      <category term="PHP学习笔记" scheme="https://www.infinitasreset.top/tags/PHP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
